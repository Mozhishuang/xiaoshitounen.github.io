<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小石头&#39;s Blog</title>
  
  <subtitle>成功来源于每一次的坚持</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://182.254.228.71/"/>
  <updated>2021-03-23T04:55:00.000Z</updated>
  <id>http://182.254.228.71/</id>
  
  <author>
    <name>小石头</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android项目：二手房</title>
    <link href="http://182.254.228.71/Android%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BA%8C%E6%89%8B%E6%88%BF/"/>
    <id>http://182.254.228.71/Android%E9%A1%B9%E7%9B%AE%EF%BC%9A%E4%BA%8C%E6%89%8B%E6%88%BF/</id>
    <published>2021-03-23T04:55:00.000Z</published>
    <updated>2021-03-23T04:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-视觉效果"><a href="#1-视觉效果" class="headerlink" title="1.视觉效果"></a>1.视觉效果</h3><blockquote><p>Github地址：<a href="https://github.com/xiaoshitounen/SecondHouse">https://github.com/xiaoshitounen/SecondHouse</a></p></blockquote><p><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_first.jpg" alt=""><br><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_second.jpg" alt=""><br><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_third.jpg" alt=""><br><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_fourth.jpg" alt=""><br><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_fiveth.jpg" alt=""></p><h3 id="2-使用到的第三方库"><a href="#2-使用到的第三方库" class="headerlink" title="2.使用到的第三方库"></a>2.使用到的第三方库</h3><p>1&gt; 完成沉浸式状态栏：<a href="https://github.com/gyf-dev/ImmersionBar">ImmersionBar</a></p><p>2&gt; 自定义标题栏：<a href="https://github.com/wuhenzhizao/android-titlebar">android-titlebar</a></p><p>3&gt; 网络请求：<a href="https://github.com/square/okhttp">okhttp</a></p><p>4&gt; Json数据解析：<a href="https://github.com/google/gson">gson</a></p><p>5&gt; 图片加载：<a href="https://github.com/bumptech/glide">glide</a></p><p>6&gt; 轮播图：<a href="https://github.com/youth5201314/banner">banner</a></p><p>7&gt; 智能刷新：<a href="https://github.com/scwang90/SmartRefreshLayout">SmartRefreshLayout</a> — 智能刷新库API介绍: <a href="https://www.jianshu.com/p/29e315ff44a6">Android智能刷新框架SmartRefreshLayout</a></p><p>8&gt; 图片放大浏览：<a href="https://github.com/SherlockGougou/BigImageViewPager">BigImageViewPager</a></p><p>9&gt; 相机相册选择图片：<a href="https://github.com/HuanTanSheng/EasyPhotos">EasyPhotos</a></p><p>10&gt; 本地数据库操作：<a href="https://developer.android.com/jetpack/androidx/releases/room">room</a></p><p>11&gt; 腾讯云对象存储存储头像：<a href="https://cloud.tencent.com/document/product/436/12159#1.-.E5.AE.9E.E7.8E.B0.E8.8E.B7.E5.8F.96.E4.B8.B4.E6.97.B6.E5.AF.86.E9.92.A5">cos-xml</a></p><h3 id="3-房源信息爬取"><a href="#3-房源信息爬取" class="headerlink" title="3.房源信息爬取"></a>3.房源信息爬取</h3><p>如何爬取链家房源信息参考我的另一个项目：<a href="https://github.com/xiaoshitounen/SecondHouseSpider">https://github.com/xiaoshitounen/SecondHouseSpider</a></p><h3 id="4-后端API介绍"><a href="#4-后端API介绍" class="headerlink" title="4.后端API介绍"></a>4.后端API介绍</h3><p>后端使用的是云服务器CentOS，采用Apache + PHP的方案</p><p>① 获取指定城市区县信息，目前只支持cq(重庆)和gz(广州)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;config.php?city&#x3D;cq</span><br><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;config.php?city&#x3D;gz</span><br></pre></td></tr></table></figure><p>② 获取指定城市 指定区县 指定偏移的 10条房子信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;message.php?city&#x3D;cq&amp;area&#x3D;yubei&amp;offset&#x3D;3</span><br><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;message.php?city&#x3D;gz&amp;area&#x3D;haizhu&amp;offset&#x3D;3</span><br></pre></td></tr></table></figure><p>③ 获取指定城市 指定房子的基本属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;base.php?city&#x3D;cq&amp;house&#x3D;1</span><br></pre></td></tr></table></figure><p>④ 获取指定城市 指定房子的交易属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;business.php?city&#x3D;cq&amp;house&#x3D;1</span><br></pre></td></tr></table></figure><p>⑤ 获取指定城市 指定房子的特色信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;special.php?city&#x3D;cq&amp;house&#x3D;1</span><br></pre></td></tr></table></figure><p>⑥ 获取指定城市 指定房子的图片信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;picture.php?city&#x3D;cq&amp;house&#x3D;1</span><br></pre></td></tr></table></figure><p>⑦ 获取指定城市 指定id的房子信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;182.254.228.71&#x2F;secondhouse&#x2F;house.php?city&#x3D;gz&amp;house&#x3D;1</span><br></pre></td></tr></table></figure><h3 id="5-整体架构"><a href="#5-整体架构" class="headerlink" title="5.整体架构"></a>5.整体架构</h3><p><img src="https://android-project-1300729795.cos.ap-guangzhou.myqcloud.com/secondhouseandroid/second_house_framework.png" alt=""></p><h3 id="6-爬虫项目"><a href="#6-爬虫项目" class="headerlink" title="6.爬虫项目"></a>6.爬虫项目</h3><blockquote><p>Github地址：<a href="https://github.com/xiaoshitounen/SecondHouseSpider">https://github.com/xiaoshitounen/SecondHouseSpider</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>个人生活-2021生活目标</title>
    <link href="http://182.254.228.71/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB-2021%E7%94%9F%E6%B4%BB%E7%9B%AE%E6%A0%87/"/>
    <id>http://182.254.228.71/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB-2021%E7%94%9F%E6%B4%BB%E7%9B%AE%E6%A0%87/</id>
    <published>2021-01-17T12:38:00.000Z</published>
    <updated>2021-01-17T12:38:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-生活目标"><a href="#一-生活目标" class="headerlink" title="一.生活目标"></a>一.生活目标</h3><h4 id="1-租房"><a href="#1-租房" class="headerlink" title="1.租房"></a>1.租房</h4><p>注意好好找房子，考虑多个因素。</p><ul><li>方便收拾，装修简洁 大方</li><li>可以养小猫咪</li><li>有厨房，培养自己做美食的爱好</li><li>考虑自如租房，公司补贴</li></ul><h4 id="2-学会理财"><a href="#2-学会理财" class="headerlink" title="2.学会理财"></a>2.学会理财</h4><p>了解基金</p><h4 id="3-瘦小腿、减肥"><a href="#3-瘦小腿、减肥" class="headerlink" title="3.瘦小腿、减肥"></a>3.瘦小腿、减肥</h4><p>B站看视频，使用滚轴-瘦小腿</p><h4 id="4-注意穿着搭配"><a href="#4-注意穿着搭配" class="headerlink" title="4.注意穿着搭配"></a>4.注意穿着搭配</h4><h4 id="5-提高情商"><a href="#5-提高情商" class="headerlink" title="5.提高情商"></a>5.提高情商</h4><p>注意表达</p><h3 id="二-痤疮对待"><a href="#二-痤疮对待" class="headerlink" title="二.痤疮对待"></a>二.痤疮对待</h3><p><strong>长期服用的药物：</strong></p><p><code>维胺酯胶囊</code></p><ul><li>服用点：坚持服用三个月以上，主要用于治疗重，中度痤疮，克制油腻皮肤。</li><li>服用方式：一日三次，每次2粒。</li></ul><p><strong>发炎服用的药物：</strong></p><p><code>盐酸米诺环素胶囊</code></p><ul><li>服用点：内服，</li><li>服用方式：一日两次，每次0.1g(500mg的胶囊*2)，坚持服用6周以上，首次服用需要0.2g。</li></ul><p><code>夫西地酸乳膏</code></p><ul><li>服用点：外服，注意脫皮保护。</li><li>服用方式：早晚各一次，囊肿处涂抹。</li></ul><p><strong>清热解毒：</strong></p><p><code>百癣夏塔热胶囊</code></p><ul><li>服用点：清热解读</li><li>服用方式：一日三次，每次两粒，饭前服用。</li></ul><p><strong>皮肤修复：</strong></p><p><code>可丽金类人胶原蛋白疤痕修复硅凝胶</code></p><ul><li>服用点：祛除疤痕</li><li>服用方式：每天两次，囊肿型好了后立即使用防止留疤，其他疤痕地区也可以使用。</li></ul><p><strong>其他注意：</strong></p><ul><li>辛辣、油炸、高热量、甜的食物，一概拒绝。代表性的火锅、奶茶、巧克力等。</li><li>每天多喝水，保持皮肤不缺水，每天最少8杯水，从起床的第一杯水开始。</li><li>一天8小时，早睡早起不熬夜。</li><li>不要去抠、挤、挑脸上的痘痘。</li><li>合理护肤，合适的洗面奶+护肤水。</li></ul><p><strong>参考：</strong><br><a href="https://www.zhihu.com/question/42651530">服用盐酸米诺环素六周治疗痤疮有何副作用？</a><br><a href="https://www.zhihu.com/question/38554081">囊肿型痘痘怎么消下去？</a><br><a href="https://www.zhihu.com/question/282981125"></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
    
      <category term="个人生活" scheme="http://182.254.228.71/tags/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-使用Admin插件构建后台</title>
    <link href="http://182.254.228.71/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/"/>
    <id>http://182.254.228.71/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/</id>
    <published>2020-12-31T09:34:00.000Z</published>
    <updated>2020-12-31T09:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-插件介紹"><a href="#一-插件介紹" class="headerlink" title="一.插件介紹"></a>一.插件介紹</h3><p><a href="https://github.com/jaredly/hexo-admin">hexo-admin</a>是一个Hexo博客引擎的管理用户界面插件。这个插件最初是作为本地编辑器设计的，在本地运行hexo使用hexo-admin编写文章。</p><p>安装方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;命令预览</span><br><span class="line">hexo -s</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入后台编辑</span><br><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;admin</span><br></pre></td></tr></table></figure><p>界面预览：<br><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/hexo_admin_1.jpeg" alt=""></p><h3 id="二-使用"><a href="#二-使用" class="headerlink" title="二.使用"></a>二.使用</h3><h4 id="1-修改文章标题"><a href="#1-修改文章标题" class="headerlink" title="1.修改文章标题"></a>1.修改文章标题</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/hexo_admin_2.png" alt=""></p><h4 id="2-修改文件名称"><a href="#2-修改文件名称" class="headerlink" title="2.修改文件名称"></a>2.修改文件名称</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/hexo_admin_3.png" alt=""></p><h4 id="3-修改Category和Tag"><a href="#3-修改Category和Tag" class="headerlink" title="3.修改Category和Tag"></a>3.修改Category和Tag</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Hexo-%E4%BD%BF%E7%94%A8Admin%E6%8F%92%E4%BB%B6%E6%9E%84%E5%BB%BA%E5%90%8E%E5%8F%B0/hexo_admin_4.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://182.254.228.71/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://182.254.228.71/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-博客更换主题Butterfly</title>
    <link href="http://182.254.228.71/Hexo-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98Butterfly/"/>
    <id>http://182.254.228.71/Hexo-%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98Butterfly/</id>
    <published>2020-12-13T08:22:00.000Z</published>
    <updated>2020-12-13T08:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-下载Buttlerfly使用"><a href="#一-下载Buttlerfly使用" class="headerlink" title="一.下载Buttlerfly使用"></a>一.下载Buttlerfly使用</h3><blockquote><p>前提：Hexo的版本至少需要时5.0.0或者更高。更新有问题可以参考：<a href="https://shenbo.github.io/2020/07/30/hexo/hexo-%E5%8D%87%E7%BA%A7%E8%87%B3%20HEXO%205.0/">Hexo 升级至 5.0 版</a></p></blockquote><p>参考：<a href="https://butterfly.js.org/posts/21cfbf15/#%E5%AE%89%E8%A3%9D">Butterfly 安裝文檔(一) 快速開始</a></p><h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a>1.下载</h4><p>本地博客根目录执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;butterfly</span><br></pre></td></tr></table></figure><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><p>修改站点配置文件<code>_config.yml</code>，把主题改为<code>butterfly</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>可能会遇到问题，请安装下面的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><h4 id="3-主题配置文件"><a href="#3-主题配置文件" class="headerlink" title="3.主题配置文件"></a>3.主题配置文件</h4><p>把主题文件夹中的 <code>_config.yml</code>复制到 Hexo 根目录，同时重新命名为<code>_config.butterfly.yml</code>。以后只需要在<code>_config.butterfly.yml</code>進行配置就行。</p><p>Hexo会自动合并主题中的<code>_config.yml</code>和<code>_config.butterfly.yml里的配置，如果存在同名配置，會使用</code>_config.butterfly.yml`的配置，其优先度较高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://182.254.228.71/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://182.254.228.71/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MacOS-使用脚本减少重复工作</title>
    <link href="http://182.254.228.71/MacOS-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E5%B7%A5%E4%BD%9C/"/>
    <id>http://182.254.228.71/MacOS-%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E5%B7%A5%E4%BD%9C/</id>
    <published>2020-12-13T08:13:47.000Z</published>
    <updated>2020-12-13T08:13:47.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-为什么需要"><a href="#1-为什么需要" class="headerlink" title="1.为什么需要"></a>1.为什么需要</h4><p>由于重复性的工作很多，并且这些是固定的，所以我们需要使用脚本。</p><p>例如Hexo本地预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/xulei/Documents/HexoBlog</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>例如Hexo的更新—进入到Hexo博客的根目录并执行部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /Users/xulei/Documents/HexoBlog</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始执行hexo clean&quot;</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始执行hexo g &amp;&amp; gulp&quot;</span> </span><br><span class="line">hexo g &amp;&amp; gulp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;开始执行hexo d&quot;</span> </span><br><span class="line">hexo d</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;连接小石头的云服务器，拉取博客最新内容更新&quot;</span> </span><br><span class="line">ssh -i /Users/xulei/Documents/云服务器/centos_xl root@182.254.228.71 <span class="string">&quot;cd / ; ./run.sh&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-制作脚本"><a href="#2-制作脚本" class="headerlink" title="2.制作脚本"></a>2.制作脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建脚本</span></span><br><span class="line">vi name.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行脚本</span></span><br><span class="line">bash name.sh的绝对路径</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/79c8b650b4af">Mac 制作一个可执行脚本</a></p><h4 id="3-脚本制作如何传入参数"><a href="#3-脚本制作如何传入参数" class="headerlink" title="3.脚本制作如何传入参数"></a>3.脚本制作如何传入参数</h4><p>例如在桌面创建一个支持传入名字的脚本文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># newsh.sh</span></span><br><span class="line"><span class="built_in">cd</span> /Users/xulei/Desktop</span><br><span class="line">filename=<span class="variable">$1</span></span><br><span class="line">vi <span class="variable">$1</span>.sh</span><br><span class="line">open <span class="variable">$1</span>.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 在桌面创建一个test.sh文件并打开</span></span><br><span class="line">bash newsh.sh <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h4 id="4-批量替换"><a href="#4-批量替换" class="headerlink" title="4.批量替换"></a>4.批量替换</h4><p>如果执行<code>bash /Users/xulei/Desktop/commandr.sh https:\/\/fanandjiu.com\/ \/</code>命令，那么就会针对<code>/Users/xulei/Documents/HexoBlog/source/_posts</code>文件夹下所有文件，首先判断是否包含字段<code>https://fanandjiu.com/</code>，如果包含就会替换成<code>/</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bash /Users/xulei/Desktop/commandr.sh https:\/\/\/fanandjiu.com\/ \/</span></span><br><span class="line">text=<span class="variable">$1</span></span><br><span class="line">newtext=<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入操作的文件目录下</span></span><br><span class="line"><span class="built_in">cd</span> /Users/xulei/Documents/HexoBlog/<span class="built_in">source</span>/_posts</span><br><span class="line"></span><br><span class="line"><span class="comment"># grep所有有text的文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `grep -rn <span class="variable">$text</span> .`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="comment"># cut 出绝对路径</span></span><br><span class="line">    file_name=`<span class="built_in">echo</span> <span class="variable">$file</span> | cut -d <span class="string">&#x27;:&#x27;</span> -f 1`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;in [<span class="variable">$file_name</span>] want replace [<span class="variable">$text</span>] to [<span class="variable">$newtext</span>]&quot;</span></span><br><span class="line">    <span class="comment"># sed 就是把所有file_name 文件中的text 全部替换为newtext，至此达到目标</span></span><br><span class="line">    sed -i <span class="string">&quot;&quot;</span> <span class="string">&quot;s#<span class="variable">$&#123;text&#125;</span>#<span class="variable">$&#123;newtext&#125;</span>#g&quot;</span> <span class="variable">$&#123;file_name&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="MacOS" scheme="http://182.254.228.71/categories/MacOS/"/>
    
    
      <category term="MacOS" scheme="http://182.254.228.71/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>开发工具-轻量应用服务器CentOS</title>
    <link href="http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8CentOS/"/>
    <id>http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E8%BD%BB%E9%87%8F%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8CentOS/</id>
    <published>2020-12-12T16:10:35.000Z</published>
    <updated>2020-12-12T16:10:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-购买云服务器"><a href="#一-购买云服务器" class="headerlink" title="一. 购买云服务器"></a>一. 购买云服务器</h3><p>我的云服务器地址：<a href="https://console.cloud.tencent.com/lighthouse/instance/detail?rid=1&amp;id=lhins-cy2o2cit&amp;tab=application&amp;action=DescribeInstanceLoginKeyPair">https://console.cloud.tencent.com/lighthouse/instance/detail?rid=1&amp;id=lhins-cy2o2cit&amp;tab=application&amp;action=DescribeInstanceLoginKeyPair</a></p><p>我购买的是腾讯云的轻量应用服务器，学生价格。</p><p>系统不建议直接使用应用型的(我曾经使用过宝塔Linux，感觉配置难受)，直接选择Cent OS8吧。</p><h3 id="二-配置Apache-PHP"><a href="#二-配置Apache-PHP" class="headerlink" title="二.配置Apache+PHP"></a>二.配置Apache+PHP</h3><h4 id="1-Apache"><a href="#1-Apache" class="headerlink" title="1.Apache"></a>1.Apache</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下载Apache</span><br><span class="line">yum -y install httpd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看Apache版本</span><br><span class="line">httpd -v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动Apache服务</span><br><span class="line">systemctl start httpd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重启Apache服务</span><br><span class="line">systemctl restart httpd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置开机自启动</span><br><span class="line">systemctl enable httpd</span><br></pre></td></tr></table></figure><blockquote><p>存放共享文件的目录是：/var/www/html/</p></blockquote><h4 id="2-PHP"><a href="#2-PHP" class="headerlink" title="2.PHP"></a>2.PHP</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下载php</span><br><span class="line">yum -y install php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看php的版本</span><br><span class="line">php -v</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重启服务</span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>Cent OS不像Window或者Mac下配置一样需要去修改PHP的配置文件<strong>php.ini</strong>文件(/etc/php.ini)以及去修改Apache的配置文件<strong>httpd.conf</strong>文件(/etc/httpd/conf/httpd.conf)。</p><p>1&gt;PHP的Json扩展问题</p><p>这里有一个问题，那就是CentOS下的Json扩展需要我们自己去下载。<del>坑了我好几天</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装PHP的Json扩展</span><br><span class="line">yum install php-json</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/ahstudy/article/details/7210234">https://blog.csdn.net/ahstudy/article/details/7210234</a></p><p>PHP扩展问题：<br>这里就要说到安装php的几种方式了：可以参考这篇文章：<a href="https://www.cnblogs.com/alliancehacker/p/12255445.html">Centos8（Liunx） 中安装PHP7.4 的三种方法和删除它的三种方法</a></p><p>这是因为我是使用yum安装php的，导致很多扩展没有安装，直到我去下载<code>mysqli</code>扩展才发现问题，很多扩展需要自己装。</p><p>安装方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;安装其他扩展只需要将mysqli换成其他扩展名即可</span><br><span class="line">yum install php-mysqli --skip-broken</span><br></pre></td></tr></table></figure><p>2&gt;PHP的错误日志</p><p>Json扩展的问题之所以坑了我好久是因为我看不到错误日志，查看PHP的错误日志参考：<a href="https://blog.csdn.net/qq_42176520/article/details/83544429">https://blog.csdn.net/qq_42176520/article/details/83544429</a></p><p>3&gt;PHP的配置文件详解</p><p>参考：<a href="https://www.jianshu.com/p/9cfd3efe8e6b">php配置文件详解</a></p><p>参考：<a href="https://blog.csdn.net/qingwage222/article/details/84199269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">php.ini修改生效</a></p><h4 id="3-宝塔Linux"><a href="#3-宝塔Linux" class="headerlink" title="3.宝塔Linux"></a>3.宝塔Linux</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><p>安装参考：<a href="https://blog.csdn.net/lxw983520/article/details/102964959">centos8安装宝塔</a></p><p>使用宝塔Linux的原因是其可视化能力，我主要是使用其文件夹能力(非常方便编辑，相当于有了窗口)，强烈建议软件安装不要使用宝塔Linux。</p><h3 id="三-CentOS-基本情况"><a href="#三-CentOS-基本情况" class="headerlink" title="三.CentOS 基本情况"></a>三.CentOS 基本情况</h3><h4 id="1-SCP"><a href="#1-SCP" class="headerlink" title="1.SCP"></a>1.SCP</h4><p>本地计算机(Mac OS)上传文件到云服务器(Cent OS)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本地文件上传</span><br><span class="line">scp 本地计算机文件路径 云服务器用户名@云服务器ip:云服务器存储地址</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例子 &#x2F;Users&#x2F;xulei&#x2F;Desktop&#x2F;CentOS182.254.228.71.md copy to &#x2F;var&#x2F;www&#x2F;html </span><br><span class="line">scp &#x2F;Users&#x2F;xulei&#x2F;Desktop&#x2F;CentOS182.254.228.71.md root@182.254.228.71:&#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本地文件夹(包含嵌套的所有内容)上传</span><br><span class="line">scp -r 本地计算机文件路径 云服务器用户名@云服务器ip:云服务器存储地址</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;Library&#x2F;WebServer&#x2F;Documents copy to &#x2F;var&#x2F;www&#x2F;html</span><br><span class="line">scp -r &#x2F;Library&#x2F;WebServer&#x2F;Documents root@182.254.228.71:&#x2F;var&#x2F;www&#x2F;html</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/ludongdong/article/details/78524653">CentOS下上传和下载文件</a></p><p><a href="https://blog.csdn.net/wyounger/article/details/98943407">【原创】Mac电脑怎么上传文件到CentOS服务器</a></p><h4 id="2-常见的文件操作命令"><a href="#2-常见的文件操作命令" class="headerlink" title="2.常见的文件操作命令"></a>2.常见的文件操作命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建文件</span><br><span class="line">vi 路径&#x2F;文件名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建文件夹</span><br><span class="line">mkdir 路径&#x2F;文件夹名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除文件或文件夹</span><br><span class="line">rm 路径--------经常会遇到权限不足，无法删除</span><br><span class="line">rm -r 路径-----递归删除路径及其子路径，当删除到具有写保护文件的时候提示用户</span><br><span class="line">rm -rf 路径----递归删除路径及其子路径，不提示用户</span><br><span class="line">rm -ir 路径----是交互模式，删除任何文件都会提示</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移动文件</span><br><span class="line">mv 源文件路径 目标文件路径</span><br><span class="line">mv 源文件1路径&#x2F;源文件2路径 目标文件路径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;复制文件</span><br><span class="line">cp 源文件路径 目标文件路径</span><br><span class="line">cp -r 源文件夹路径 目标文件夹路径</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/yeluo_vinager/article/details/100976353">Centos彻底删除文件夹、文件命令</a></p><h3 id="四-Hexo博客静态部署"><a href="#四-Hexo博客静态部署" class="headerlink" title="四.Hexo博客静态部署"></a>四.Hexo博客静态部署</h3><p>我们之前在本地生成好一系列文件之后上传到对应的平台例如：Github等。</p><p>其实那些仓库的内容就是我们的博客内容，因为我们是静态的，所以可以直接访问。</p><p>我们的思路就是将仓库的内容来到Apache的共享文件夹下面：</p><h4 id="1-获取内容"><a href="#1-获取内容" class="headerlink" title="1.获取内容"></a>1.获取内容</h4><p>在共享文件夹html下面创建hexo文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进入该文件夹</span><br><span class="line">cd &#x2F;var&#x2F;www&#x2F;html&#x2F;hexo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;拉取我们的静态博客内容</span><br><span class="line">git clone ...你自己仓库的地址...</span><br></pre></td></tr></table></figure><h4 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;html&#x2F;hexo&#x2F;xiaoshitounen.github.io</span><br><span class="line">&#x2F;&#x2F;更新博客内容</span><br><span class="line">git pull origin master</span><br><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">&#x2F;&#x2F;将内容copy到Apache的共享文件夹下面</span><br><span class="line">cp -rf html&#x2F;hexo&#x2F;xiaoshitounen.github.io&#x2F;* html&#x2F;</span><br></pre></td></tr></table></figure><p>这样子我们就可以通过云服务的公网ip访问我们的静态博客了。例如我的：<a href="http://182.254.228.71">http://182.254.228.71</a></p><h4 id="3-更新问题"><a href="#3-更新问题" class="headerlink" title="3.更新问题"></a>3.更新问题</h4><p>在CentOS的根目录(/)下，创建一个脚本文件<strong>run.sh</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;html&#x2F;hexo&#x2F;xiaoshitounen.github.io</span><br><span class="line">git pull origin master</span><br><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">cp -rf html&#x2F;hexo&#x2F;xiaoshitounen.github.io&#x2F;* html&#x2F;</span><br><span class="line">echo successful</span><br></pre></td></tr></table></figure><p>每次需要更新的时候在根目录执行我们的脚本就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;run.sh</span><br></pre></td></tr></table></figure><p>参考：<a href="https://cloud.tencent.com/developer/article/1662792?from=information.detail.hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8">Hexo进阶教程（四）| 部署Hexo到自己的服务器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发工具-Charles抓包工具的快速上手</title>
    <link href="http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-08-21T12:45:34.000Z</published>
    <updated>2020-08-21T12:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一.背景"></a>一.背景</h2><h3 id="1-下载和配置Key"><a href="#1-下载和配置Key" class="headerlink" title="1.下载和配置Key"></a>1.下载和配置Key</h3><p><a href="https://www.charlesproxy.com/download/">Charles的下载地址</a></p><h3 id="2-B站上的视频学习"><a href="#2-B站上的视频学习" class="headerlink" title="2.B站上的视频学习"></a>2.B站上的视频学习</h3><p><a href="https://www.bilibili.com/video/av625921823?p=1">快速掌握Charles抓包工具</a></p><h2 id="二-使用"><a href="#二-使用" class="headerlink" title="二. 使用"></a>二. 使用</h2><h3 id="1-两种结构"><a href="#1-两种结构" class="headerlink" title="1.两种结构"></a>1.两种结构</h3><ul><li><p>Structure/结构视图，将网络请求按访问的域名分类。</p></li><li><p>Sequence/序列视图，将网络请求按访问的时间排序，按照你的电脑的发送请求顺序进行。</p></li></ul><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/1.png" alt="img">)<img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/2.png" alt="img"></p><h3 id="2-整体内容"><a href="#2-整体内容" class="headerlink" title="2.整体内容"></a>2.整体内容</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/3.png" alt="img"></p><h3 id="3-抓取https协议请求"><a href="#3-抓取https协议请求" class="headerlink" title="3.抓取https协议请求"></a>3.抓取https协议请求</h3><h4 id="①-安装证书"><a href="#①-安装证书" class="headerlink" title="① 安装证书"></a>① 安装证书</h4><p>Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/4.png" alt="img"></p><h4 id="②-信任证书"><a href="#②-信任证书" class="headerlink" title="② 信任证书"></a>② 信任证书</h4><p>弹出的窗口 -&gt; 登录 -&gt; Charles Proxy…  -&gt; 双击设置信任为始终信任</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/5.png" alt="img"></p><h4 id="③-配置-SSL-Proxy"><a href="#③-配置-SSL-Proxy" class="headerlink" title="③ 配置 SSL Proxy"></a>③ 配置 SSL Proxy</h4><p>Proxy -&gt; SSL Proxying Settings -&gt; 添加如下信息</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/6.png" alt="img">)<img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/7.png" alt="img"></p><p>这样你就可以抓取到https的协议了，明白http和https区别的同学想必已经知道这么做的原因了吧。</p><h3 id="4-Android手机配置"><a href="#4-Android手机配置" class="headerlink" title="4.Android手机配置"></a>4.Android手机配置</h3><p>前提：手机和电脑需要连接在同一个局域网下。</p><h4 id="①-Charles操作"><a href="#①-Charles操作" class="headerlink" title="① Charles操作"></a>① Charles操作</h4><p>Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or Remote Browser</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/8.png" alt="img">)<img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/9.png" alt="img"></p><h4 id="②-手机端配置"><a href="#②-手机端配置" class="headerlink" title="② 手机端配置"></a>② 手机端配置</h4><p>根据弹出的第一个信息，配置手机连接的wifi。</p><ul><li><p>修改代理为手动</p></li><li><p>根据信息填写主机名</p></li><li><p>根据信息填写端口</p></li><li><p>保存配置</p></li><li><p>在弹出的页面点击Allow</p></li></ul><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/10.png" alt="img"></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/11.png" alt="img"></p><h4 id="③-下载-安装证书"><a href="#③-下载-安装证书" class="headerlink" title="③ 下载/安装证书"></a>③ 下载/安装证书</h4><p>（建议不要使用默认的浏览器，否则不能直接点击下载的文件进行安装。）</p><p>打开手机浏览器，往地址栏输入 <strong>chrl.pro/ssl</strong> 回车，下载证书后点击证书安装。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Charles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/12.png" alt="img"> </p><p>之后，就可以在Charles中拦截到手机端发送的请求了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发工具-新人ADB快速上手</title>
    <link href="http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-08-19T06:23:40.000Z</published>
    <updated>2020-08-19T06:23:40.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="1-关于ADB"><a href="#1-关于ADB" class="headerlink" title="1.关于ADB"></a>1.关于ADB</h3><ul><li><p><strong>ADB</strong>是一个 客户端-服务器端 程序, 其中客户端是你用来操作的电脑, 服务器端是android设备。</p></li><li><p><strong>ADB</strong>—Andorid Debug Bridge，它其实是一个命令行窗口，用于通过电脑端与模拟器或者真实设备交互。在某些特殊的情况下进入不了系统，adb就派上用场啦！</p></li><li><p>我面临的使用场景：覆盖率数据不接受debug测试包的数据上报，所以我必须使用release包测试。拿到一个release包如何查看日志呢？这个时候就驱动我去学习adb了。</p></li></ul><h3 id="2-ADB用法大全"><a href="#2-ADB用法大全" class="headerlink" title="2.ADB用法大全"></a>2.ADB用法大全</h3><p><a href="https://github.com/mzlogin/awesome-adb">https://github.com/mzlogin/awesome-adb</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-测试是否安装"><a href="#1-测试是否安装" class="headerlink" title="1.测试是否安装"></a>1.测试是否安装</h3><p>输入以下命令，查看adb的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure><p>如果出现类似下面的情况，证明已经安装了：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/1.png" alt="img"></p><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h3><p>详细参考简书猿二胖，具体链接为<a href="https://www.jianshu.com/p/229dbd25b661">https://www.jianshu.com/p/229dbd25b661</a></p><p>我是直接使用下面的命令，然后检测是否安装成功即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install android-platform-tools</span><br></pre></td></tr></table></figure><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="1-查看连接的设备"><a href="#1-查看连接的设备" class="headerlink" title="1.查看连接的设备"></a>1.查看连接的设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/2.png" alt="img"></p><h3 id="2-安装apk"><a href="#2-安装apk" class="headerlink" title="2.安装apk"></a>2.安装apk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install &lt;Mac上apk的路径&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/3.png" alt="img"></p><blockquote><p>Mac上获取apk路径的小技巧：直接将一个apk文件拖到终端，终端就会出现apk的路径</p></blockquote><h3 id="3-卸载apk"><a href="#3-卸载apk" class="headerlink" title="3.卸载apk"></a>3.卸载apk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall &lt;包名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/4.png" alt="img"></p><h3 id="4-获取包名"><a href="#4-获取包名" class="headerlink" title="4.获取包名"></a>4.获取包名</h3><p>查看所有app的包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure><p>查看所有系统app的包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure><p>查看所有第三方app的包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure><p>使用grep过滤查看满足要求的app包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages | grep &lt;条件&gt;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/5.png" alt="img"></p><h3 id="5-清除应用数据"><a href="#5-清除应用数据" class="headerlink" title="5.清除应用数据"></a>5.清除应用数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear</span><br></pre></td></tr></table></figure><blockquote><p>当你只是想要清除一个apk的某些数据来复现某些操作的时候，这个命令就显得尤为重要。它可以避免我们重装apk来完成这个操作。</p></blockquote><h3 id="6-查看日志"><a href="#6-查看日志" class="headerlink" title="6.查看日志"></a>6.查看日志</h3><p>打印 Android 的系统日志   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure><p>清除日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure><p>过滤日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat | grep &quot;tag&quot;</span><br></pre></td></tr></table></figure><blockquote><p>这里的tag就是你打日志的时候需要设置的第一个参数TAG，通过TAG我们可以很轻松的过滤出我们想要的日志，轻松高效。</p></blockquote><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/6.png" alt="img"></p><h3 id="7-查看设备信息"><a href="#7-查看设备信息" class="headerlink" title="7.查看设备信息"></a>7.查看设备信息</h3><p>① 查看序列号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb get-serialno</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/7.png" alt="img"></p><p>② 查看Mac地址（需要权限）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/8.png" alt="img"></p><p>③ 查看设备型号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/9.png" alt="img"></p><p>④ 查看设备的android版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/10.png" alt="img"></p><p>⑤ 查看屏幕分辨率</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/11.png" alt="img"></p><p>⑥ 查看屏幕密度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/12.png" alt="img"></p><h2 id="ADB-IDEA"><a href="#ADB-IDEA" class="headerlink" title="ADB IDEA"></a>ADB IDEA</h2><p>AS 插件 ADB IDEA ，装了这款插件可以直接在 AS 中快速操作一些 ADB 命令。</p><p>使用方式：</p><p>① 双击shift-&gt;点击action-&gt;搜索adb</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/13.png" alt="img"></p><p>② Ctrl + Shift + A，快捷键直接调用</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BAADB%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/14.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发工具-新人零基础Git快速上手</title>
    <link href="http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
    <id>http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</id>
    <published>2020-08-14T12:32:58.000Z</published>
    <updated>2020-08-14T12:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文旨在让0基础的人快速掌握Git的操作，方便快速进入工作的状态。</p><p>我个人的观点是：单独抽出时间研究Git是不高效的并且也是脱离实际的，经历过实际使用才能更好更快的理解Git。所以，本篇文章主要涉及实际使用中的场景，并不会系统的介绍Git或者说讲解Git的原理。</p><h2 id="Git单分支开发"><a href="#Git单分支开发" class="headerlink" title="Git单分支开发"></a>Git单分支开发</h2><h3 id="1-从拥有一个git管理的仓库开启"><a href="#1-从拥有一个git管理的仓库开启" class="headerlink" title="1.从拥有一个git管理的仓库开启"></a>1.从拥有一个git管理的仓库开启</h3><p>Android开发的同学一定很熟悉Android项目，那我们就用它来做为我们操作的对象。</p><p>我的操作是在桌面创建一个新的Android项目，然后在终端中进入该项目目录中，使用如下命令初始化仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>此时，我们只是做了一个初始化的操作，当前目录下所有的文件都是没有被跟踪的，我们可以使用如下的命令查看文件状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/1.png" alt="img"></p><p>我们逐一解读 git status 后出现的输出：</p><ul><li><p>On branch master：当前分支处于master分支</p></li><li><p>No commits yet：还没有依次提交过</p></li><li><p>Untracked files：工作目录中没有跟踪过的文件，红色的部分就是我们没有被追踪的文件</p></li></ul><h3 id="2-尝试第一次追踪文件"><a href="#2-尝试第一次追踪文件" class="headerlink" title="2.尝试第一次追踪文件"></a>2.尝试第一次追踪文件</h3><p>我们初始化仓库后，所有的文件都是未跟踪的，那么如何跟踪文件呢？不知道你们有没有注意到使用git status后输出信息中的一些提示呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br></pre></td></tr></table></figure><p>根据Git的提示我们知道了跟踪文件的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>比如说我想追踪 app/ 下所有文件，那么我们就可以这样写命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add app&#x2F;</span><br></pre></td></tr></table></figure><p>一个一个的添加命令看起来有点蠢，如果我们要追踪所有的文件，要一次一次的add吗？大可不必，我们可以使用以下的命令将所有的文件设置为追踪状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><p>如果我们将所有的文件设置为追踪状态，使用git status查看文件状态又会出现什么呢？</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/2.png" alt="img"></p><p>类比之前提示追踪文件的命令的结果，我们可以得出如何取消追踪一个文件的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><h3 id="3-尝试第一次提交文件"><a href="#3-尝试第一次提交文件" class="headerlink" title="3.尝试第一次提交文件"></a>3.尝试第一次提交文件</h3><p>我们追踪过文件后，Git提示我们 Changes to be committed，那我们该如何提交呢？</p><p>我们使用如下的命令进行提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;本次提交内容的总结&quot;</span><br></pre></td></tr></table></figure><p>我们commit的时候可以看到具体的改变情况： 41 files changed, 939 insertions(+)</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/3.png" alt="img"></p><p>我们使用git status再次查看文件状态发现，nothing to commit, working tree clean表明我们什么东西是可以提交的，working tree也是干净的。</p><h3 id="4-尝试此时修改文件后会发生什么"><a href="#4-尝试此时修改文件后会发生什么" class="headerlink" title="4.尝试此时修改文件后会发生什么"></a>4.尝试此时修改文件后会发生什么</h3><p>我的修改内容如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/4.png" alt="img"></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/5.png" alt="img"></p><p>此时我们使用git status查看文件状态会发生什么呢？</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/6.png" alt="img"></p><p>Git提示我们有两个文件被修改了，它们还没有被暂存。并且Git告诉了我们如何更新我们修改的文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;此时我们又知道了git add的一个功能</span><br><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><p>以及如何放弃工作目录中的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新版本的命令</span><br><span class="line">git restore &lt;file&gt;</span><br><span class="line">&#x2F;&#x2F;旧版本的命令，使用新版本是为了分担git checkout承担的压力</span><br><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>如果我们想要仔细查看具体的改变，该怎么做呢？我们可以使用下面的命令查看非暂存区相对于暂存区的改变(按任意键退出查询状态)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/7.png" alt="img"></p><p>我们此时将修改的文件更新到暂存区，查看文件状态如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/8.png" alt="img"></p><p>通过Git的提示，我们看到了如何取消我们刚才暂存的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;新版本命令，为了分担git reset命令过多功能的压力</span><br><span class="line">git restore --staged &lt;file&gt;</span><br><span class="line">&#x2F;&#x2F;旧版本命令</span><br><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>那，如果我们此时再修改文件会发生什么呢，比如我们将text.<em>text</em> = “你好”修改为text.<em>text</em> = “你不好”，此时查看文件状态如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/9.png" alt="img"></p><p>我们看到MainActivity同时出现在暂存区和非暂存区，这是怎么回事？我们暂存区的文件实际上是你执行git add的时候文件的状态，由于有了新的改变所以又出现在了非暂存区。我们执行git commit是提交暂存区中的数据。</p><h3 id="5-理解Git的管理过程"><a href="#5-理解Git的管理过程" class="headerlink" title="5.理解Git的管理过程"></a>5.理解Git的管理过程</h3><p>首先我们要知道，我们的工作目录中有很多文件，每个文件又会有很多种状态。所以，我们第一个需要理清的东西就是文件的状态。</p><p>仓库刚初始化的时候，文件是“没有跟踪的-Untracked”，使用“git add <file>”命令会成为“跟踪的-Tracked”。只有跟踪的文件才是受Git管理的。</p><p>对于暂存区，非暂存区的理解，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”</p><p>HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 <strong>你的上一次提交</strong> 的快照。</p><table><thead><tr><th>树</th><th>用途</th></tr></thead><tbody><tr><td>Head</td><td>上一次提交的快照，下一次提交的父节点</td></tr><tr><td>Index</td><td>暂存区，预期下一次提交的快照</td></tr><tr><td>Working Directory</td><td>我们工作目录中跟踪的文件</td></tr></tbody></table><p>我们以Pro Git的讲解来理解：</p><p>假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 <strong>v1</strong> 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（master 还不存在）。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/10.png" alt="img"></p><p>此时，只有工作目录有内容。现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/11.png" alt="img"></p><p>接着运行 git commit，它首先会将索引中的内容保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/12.png" alt="img"></p><p>此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 <strong>v2</strong> 版本，并将它标记为红色。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/13.png" alt="img"></p><p>如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/14.png" alt="img"></p><p>此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/15.png" alt="img"></p><p>现在运行 git status 会没有输出，因为三棵树又变得相同了。</p><p>切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 <strong>HEAD</strong> 指向新的分支引用，将 <strong>索引</strong> 填充为该次提交的快照，然后将 <strong>索引</strong> 的内容复制到 <strong>工作目录</strong> 中。</p><h3 id="6-查看我们的提交"><a href="#6-查看我们的提交" class="headerlink" title="6.查看我们的提交"></a>6.查看我们的提交</h3><p>现在让我们回到我们之前的GitTest项目，当前的文件状态如下，我们添加到暂存区后然后提交。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/16.png" alt="img"></p><p>可以用下面的命令查看提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>上面的命令还有各种各样的花样，但是查看提交我们可以直接用SourceTree可视化工具查看：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/17.png" alt="img"></p><h3 id="7-小小的总结"><a href="#7-小小的总结" class="headerlink" title="7.小小的总结"></a>7.小小的总结</h3><p>我们用一张图总结一下我们学习的过程：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/18.png" alt="img"></p><h3 id="8-关于reset命令的奥秘"><a href="#8-关于reset命令的奥秘" class="headerlink" title="8.关于reset命令的奥秘"></a>8.关于reset命令的奥秘</h3><p>通过总结我们发现，我们似乎少了什么东西，我们好像没有讲到如何放弃一次提交？这就需要讲解reset命令了。</p><p>在讲解reset命令之前，我们先弄懂一个小知识点，git中HEAD^和HEAD~的区别？</p><p>“^”代表父提交，  如果一个提交有多个父提交，可以通过在后面追加数字，表示第几个父提交。</p><p>“^”默认是“^1”表示第一个父提交。</p><p>“<del>”代表连续的父提交，“</del>”默认是“<del>1”表示父提交，“</del>2”则是父提交的父提交。</p><p>首先我们需要明白撤销提交命令什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --[soft&#x2F;mixed&#x2F;hard] HEAD~</span><br></pre></td></tr></table></figure><p>有三种参数供选择，soft，mixed，hard，那我们接下里就依次讲解。</p><p>为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/19.png" alt="img"></p><p>让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。</p><h4 id="①-移动-HEAD"><a href="#①-移动-HEAD" class="headerlink" title="① 移动 HEAD"></a>① 移动 HEAD</h4><p>reset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上），运行 git reset 9e5e64a 将会使 master 指向 9e5e64a。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/20.png" alt="img"></p><p>无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset –soft，就只会做到这一步。</p><p>本质上是撤销了上一次 git commit 命令。</p><h4 id="②-更新索引"><a href="#②-更新索引" class="headerlink" title="② 更新索引"></a>② 更新索引</h4><p>如果指定 –mixed 选项，我们不仅会移动 HEAD 的指向，而且会取消取消暂存所有的东西。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/21.png" alt="img"></p><p>本质上是撤销了上一次 git commit 命令 + git add命令。</p><h4 id="③-更新目录"><a href="#③-更新目录" class="headerlink" title="③ 更新目录"></a>③ 更新目录</h4><p>如果指定 –hard 选项，我们不仅会移动 HEAD 的指向，取消取消暂存所有的东西，而且会改变工作目录中的内容。–hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/22.png" alt="img"></p><h3 id="9-单分支开发总结"><a href="#9-单分支开发总结" class="headerlink" title="9.单分支开发总结"></a>9.单分支开发总结</h3><p>在掌握了上面这么多内容的学习后，我想单分支开发已经难不倒我们了。</p><h2 id="Git多分支开发"><a href="#Git多分支开发" class="headerlink" title="Git多分支开发"></a>Git多分支开发</h2><h3 id="1-远程仓库的引入"><a href="#1-远程仓库的引入" class="headerlink" title="1.远程仓库的引入"></a>1.远程仓库的引入</h3><p>直接在Github上创建仓库，主要是获得SSH（例如：<a href="mailto:git@github.com">git@github.com</a>:xiaoshitounen/GitTest.git）</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/23.png" alt="img"></p><p>给我们的本地仓库，添加远程仓库，可以使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;远程仓库的简称&gt; &lt;SSH&gt;</span><br></pre></td></tr></table></figure><p>想查看我们本地仓库和多少个远程仓库有联系，可以使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -vv</span><br></pre></td></tr></table></figure><p>从下面的图片中我们可以看到，我们添加的远程仓库命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:xiaoshitounen&#x2F;GitTest.git</span><br></pre></td></tr></table></figure><p>通过添加远程仓库的时候给与远程仓库一个简称，这样我们之后想要指定某一个远程仓库的时候，可以直接使用origin来代替 “<a href="mailto:git@github.com">git@github.com</a>:xiaoshitounen/GitTest.git”。</p><p>直接git push将本地仓库的内容推送到远程仓库会失败，因为本地仓库的分支没有和远程仓库的分支建立映射关系。Git不知道你想要将当前所在分支的内容推送到远程仓库的哪一个分支。</p><p>如何将本地分支和远程分支建立关系呢？可以使用下面的命令建立联系（如果没有对应的远程分支，会创建出来）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;远程仓库简称&gt; &lt;本地仓库的分支&gt;:&lt;远程仓库的分支&gt;</span><br></pre></td></tr></table></figure><p>如果是将当前本地所在的分支和远程某一个分支建立关系，可以使用下面更加简洁的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;远程仓库简称&gt; &lt;远程仓库的分支&gt;</span><br></pre></td></tr></table></figure><p>从下面的图片中我们可以看出，我们使用了下面的命令将本地master分支和我们远程仓库master分支建立了联系，之后使用get pull就可以将本地master分支的内容同步到远程仓库的master分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/24.png" alt="img"></p><p>同步代码成功之后，就可以在Github上面的仓库中看到下面的内容了。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/25.png" alt="img"></p><p>如果我们想知道我们本地仓库添加了多少个远程仓库，我们可以使用下面的命令查看我们添加的所有远程仓库的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -vv</span><br></pre></td></tr></table></figure><h3 id="2-建立映射关系的好处"><a href="#2-建立映射关系的好处" class="headerlink" title="2.建立映射关系的好处"></a>2.建立映射关系的好处</h3><p>本地分支和远程仓库的分支建立映射关系是很方便的。</p><p>首先我们先明确几个命令：</p><ul><li><p>git push：推送本地分支的内容到远程仓库的分支</p></li><li><p>git fetch：拉取远程仓库某个分支的内容到本地</p></li><li><p>git pull：拉取远程仓库的某个分支的内容到本地，并且将内容合并到本店仓库分支</p></li></ul><p>通过比较这三个命令我们可以知道，我们在本地使用这三个命令的时候，如果不建立映射关系，我们每次使用都需要指定具体是哪一个远程仓库，是这个远程仓库的哪一个分支。</p><p>但是，一旦我们建立了联系之后，我们就可以直接使用git push，git fetch，get pull，因为我们已经知道了是和远程仓库的哪一个分支进行交流的。</p><h3 id="3-多分支"><a href="#3-多分支" class="headerlink" title="3.多分支"></a>3.多分支</h3><p>我们首先肯定是想知道我们现在有多少分支？我们可以使用下面的命令查看本地的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>继续使用上面的GitTest项目，我们可以查看我们的分支如下，我们可以看到我们只有一个名为master的分支，并且我们的分支前面有一个*，表示这是我们当前所处的分支。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/26.png" alt="img"></p><p>不仅可以查看本地分支，我们还可以查看远程分支，使用下面的命令，我们就可以查看所有的分支列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/27.png" alt="img"></p><p>那么，我们该如何创建一个分支呢？我们可以使用下面的命令创建分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;name&gt;</span><br></pre></td></tr></table></figure><p>比如我们使用命令git branch test创建分支后，查看分支列表就可以看到下面的内容：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/28.png" alt="img"></p><p>这个命令是基于当前分支的内容进行创建的，所以我们如果想要在某一个分支基础上开发，我们需要切换到对应的分支，我们可以使用下面的命令切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;name&gt;</span><br></pre></td></tr></table></figure><p>比如我们使用命令git checkout test切换分支，查看分支列表发现*对应的分支果然改变了</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/29.png" alt="img"></p><p>有时候我们想创建新分支的同时切换到对应的分支，可以使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure><p>既然我们可以创建分支，那我们肯定也想删除分支，使用下面的命令就可以删除分支(注意：不能删除当前所在分支)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><h3 id="4-分支之间的合并"><a href="#4-分支之间的合并" class="headerlink" title="4.分支之间的合并"></a>4.分支之间的合并</h3><p>1&gt; merge</p><p>我们先来看一次简单的merge情况，我们新开一个分支test，修改内容如下。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/30.png" alt="img"></p><p>我们修改后，先查看文件状态，发现我们修改的文件果然变成了“modified”状态，我们使用git操作依次添加到暂存区，然后将当前的修改做一次提交。</p><p>之后，我们切回到master分支，我们现在将test分支的内容同步到我们master分支中，可以使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>上面的命令是将test分支的内容同步到当前分支。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/31.png" alt="img"></p><p>由于，test分支是从master分支切出来的，所以我们的test分支修改后我们本地仓库的内容大致如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/32.png" alt="img"></p><p>如果我们把这三次提交拉成一条线，那么master分支到test分支就被拉成一条线可以直达，所以这种类型的合并就是直接移动msater指针到test指针的位置。merge的时候，我们也会看到Fast-forwad这样的提示。</p><p>此时，远程仓库不知道我们本地仓库master分支的内容发生了变化，而我们的本地分支master和远程仓库分支的master分支是建立过映关系的，所以我们直接使用git push将本地master分支的内容推送到远程仓库的master分支中。（注意：你本地分支一定要在master分支再执行git push操作）</p><p>推送前：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/33.png" alt="img"></p><p>推送后：</p><p><img src="https://bytedance-1300729795.cos.ap-guangzhou.myqcloud.com/Git0/test.png" alt="img"></p><p>但是，大部分的合并都不会如此的轻松。我们试着先在master分支做一些修改，然后到test分支做一些修改，最后切回到master分支，将test分支的内容同步到master分支中。</p><p>master分支的修改内容如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/34.png" alt="img"></p><p>这个时候，我们提交一次，具体操作情况如下：(某些文件的修改不是我们做的，所以我们放弃修改.idea/gradle.xml文件)</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/35.png" alt="img"></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/36.png" alt="img"></p><p>之后，我们切换到test分支，修改的内容如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/37.png" alt="img"></p><p>这个时候，我们提交一次，具体操作情况如下：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/38.png" alt="img"></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/39.png" alt="img"></p><p>这个时候，如果我们将test分支的内容合并到master分支，发现无法像上面合并的过程一样直接Fast-forwad。这个时候，git的操作是将test分支和master分支以及它们的共同祖先做一个简单的三方合并。</p><p>由于这里我们修改的是同一个地方，会出现合并冲突，具体解决冲突的情况请往下看会有视频操作。</p><p>2&gt;rebase</p><p>rebase部分我还没有实际使用过，这里参考公司文档的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git rebase &lt;BRANCH_NAME&gt;</span><br><span class="line"> rebase作用如下图所示：  </span><br><span class="line"> --------------------------rebase示例图-----------------------------</span><br><span class="line"> A--B topic(*)                   A&#39;--B&#39; topic(*) </span><br><span class="line">&#x2F;        --git rebase master--&gt;      &#x2F;         </span><br><span class="line">D--F--G master               D--F--G master      </span><br><span class="line"> -------------------------------------------------------------------</span><br><span class="line"> 简述：rebase的作用</span><br><span class="line"> 如rebase示例图，在topic上对master做rebase后，topic分支就成为master分支的完全超集了。这样，再在master上merge分支topic时，就会出现fast-forward(ff)，如下图</span><br><span class="line"> ------------------------------ff示例图-------------------------------</span><br><span class="line">     A&#39;--B&#39; topic                A&#39;--B&#39; topic    </span><br><span class="line">    &#x2F;       --git merge topic--&gt;     &#x2F;          </span><br><span class="line">D--F--G master(**)             D--F--G--A&#39;--B&#39; master(**) </span><br><span class="line"> ---------------------------------------------------------------------</span><br><span class="line"> 保证主分支在合并时ff的好处显而易见：得到一个线性增长的主分支。</span><br></pre></td></tr></table></figure><h3 id="5-不想直面的冲突"><a href="#5-不想直面的冲突" class="headerlink" title="5.不想直面的冲突"></a>5.不想直面的冲突</h3><p>首先安利一个工具：p4merge，下载地址：<a href="https://www.perforce.com/downloads">https://www.perforce.com/downloads</a></p><p>下载之后需要配置一下，参考配置地址是这个：<a href="https://gist.github.com/tony4d/3454372，直接复制下面的四条命令，依次执行下去。">https://gist.github.com/tony4d/3454372，直接复制下面的四条命令，依次执行下去。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool p4mergetool</span><br><span class="line"> </span><br><span class="line">$ git config --global mergetool.p4mergetool.cmd \</span><br><span class="line">&quot;&#x2F;Applications&#x2F;p4merge.app&#x2F;Contents&#x2F;Resources&#x2F;launchp4merge \$PWD&#x2F;\$BASE \$PWD&#x2F;\$REMOTE \$PWD&#x2F;\$LOCAL \$PWD&#x2F;\$MERGED&quot;</span><br><span class="line"> </span><br><span class="line">$ git config --global mergetool.p4mergetool.trustExitCode false</span><br><span class="line"> </span><br><span class="line">$ git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure><p>首先我们在上面的过程中了解到了merge过程产生冲突的情况，接下来我们在装了p4merge的情况，就可以使用下面的命令调用可视化工具p4merge来解决冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git meregtool</span><br></pre></td></tr></table></figure><p>刚才操作的视频演示：</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/git_show.mov","pic":"http://devtest.qiniudn.com/若能绽放光芒.png"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"http://dplayer.daoapp.io","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><p>显示三个框框的内容，左边的内容是我们想要同步的分支的内容也就是我们这里的test分支，右边的内容是我们的本地分支的内容也就是我们这里的master分支，中间的内容是它们的共同内容。</p><p>下面框框的内容就是我们最终合并的内容，合并之后，保存即可。我们这里合并就是保留master方法去除fun方法。你可以再次运行 git status 来确认所有的合并冲突都已被解决。如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。</p><p>我们可以使用SourceTree可视化工具清楚的看到，我们的确是合并了。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-%E6%96%B0%E4%BA%BA%E9%9B%B6%E5%9F%BA%E7%A1%80Git%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/40.png" alt="img"></p><p>如果，你正在合并中，那么你可以使用下面的方法来结束合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin-简单的点击事件</title>
    <link href="http://182.254.228.71/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
    <id>http://182.254.228.71/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-07-27T17:42:25.000Z</published>
    <updated>2020-07-27T17:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-认识-View-OnClickListener"><a href="#一-认识-View-OnClickListener" class="headerlink" title="一. 认识 View.OnClickListener"></a>一. 认识 View.OnClickListener</h3><h4 id="1-当前所在类实现接口"><a href="#1-当前所在类实现接口" class="headerlink" title="1. 当前所在类实现接口"></a>1. 当前所在类实现接口</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置监听者是当前类的对象，当前类的对象需要实现View.OnClickListener接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), View.OnClickListener&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置监听对象View.OnClickListener接口中的方法</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听对象实现   </span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建一个新类实现接口"><a href="#2-创建一个新类实现接口" class="headerlink" title="2. 创建一个新类实现接口"></a>2. 创建一个新类实现接口</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//传入创建的实现类</span></span><br><span class="line">        btn.setOnClickListener(Temp())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个实现View.OnClickListener接口的类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Temp</span>: <span class="type">View.OnClickListener&#123;</span></span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">            v <span class="keyword">as</span> TextView</span><br><span class="line">            v.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建匿名类实现接口"><a href="#3-创建匿名类实现接口" class="headerlink" title="3. 创建匿名类实现接口"></a>3. 创建匿名类实现接口</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用匿名类的方式</span></span><br><span class="line">        btn.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">                btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类的改造</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式，接口中只有一个重写的方法时</span></span><br><span class="line">btn.setOnClickListener(&#123;view: View -&gt; <span class="built_in">Unit</span></span><br><span class="line">    btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口重写的方法的返回值为Unit，返回值可以省略</span></span><br><span class="line">btn.setOnClickListener(&#123;view: View -&gt;</span><br><span class="line">    btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口作为最后一个参数时，可以放在外边</span></span><br><span class="line">btn.setOnClickListener()&#123;view: View -&gt;</span><br><span class="line">    btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有接口做为参数时，调用的方法的()可以省略</span></span><br><span class="line">btn.setOnClickListener&#123;view: View -&gt;</span><br><span class="line">    btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口重写的方法只有一个参数时，参数可以省略</span></span><br><span class="line">btn.setOnClickListener&#123;</span><br><span class="line">    btn.text = <span class="string">&quot;你好&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>补充知识：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前的Activity跳转到SecondActivity</span></span><br><span class="line">startActivity(Intent(<span class="keyword">this</span>,SecondActivity::<span class="keyword">class</span>.java))</span><br></pre></td></tr></table></figure><h3 id="二-认识-横竖屏"><a href="#二-认识-横竖屏" class="headerlink" title="二. 认识 横竖屏"></a>二. 认识 横竖屏</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/orition.png" alt=""></p><h4 id="1-设置Activity的横竖屏状态"><a href="#1-设置Activity的横竖屏状态" class="headerlink" title="1. 设置Activity的横竖屏状态"></a>1. 设置Activity的横竖屏状态</h4><p>AndroidManifest.xml文件中找到所要设置的Activity的标签，标签中社会组<code>screenOrientation</code>的值即可。</p><ul><li>landscape：强制横屏</li><li>portrait：强制竖屏</li><li>user：用户当前的首选方向</li><li>behind：与在活动堆栈下的活相同方向</li><li>sensor：根据物理方向传感器确定方向，取决于用户手持的方向</li><li>nosensor：忽略传感器，即关闭重力感应，跟随系统确定其横屏还是竖屏</li></ul><h4 id="2-设置对应状态的布局文件"><a href="#2-设置对应状态的布局文件" class="headerlink" title="2. 设置对应状态的布局文件"></a>2. 设置对应状态的布局文件</h4><p>默认的布局文件是竖屏状态下显示。</p><p>添加<code>layout-land</code>文件夹，存放和layout文件夹中相同的文件名，横屏状态下即会加载对应的文件。</p><h3 id="三-认识also，apply，with，run"><a href="#三-认识also，apply，with，run" class="headerlink" title="三. 认识also，apply，with，run"></a>三. 认识also，apply，with，run</h3><p>Java风格的书写方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> animator = ObjectAnimator.ofFloat(btn, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>)</span><br><span class="line">animator.duration = <span class="number">1000</span></span><br><span class="line">animator.start()</span><br></pre></td></tr></table></figure><h4 id="1-also"><a href="#1-also" class="headerlink" title="1. also"></a>1. also</h4><p>改写成also的方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(btn, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>).also &#123; </span><br><span class="line">    it.duration = <span class="number">1000</span></span><br><span class="line">    it.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>also的原理</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="meta-string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply"></a>2. apply</h4><p>改写成apply的方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(btn, <span class="string">&quot;rotation&quot;</span>, <span class="number">0f</span>, <span class="number">360f</span>).apply &#123;</span><br><span class="line">    duration = <span class="number">1000</span></span><br><span class="line">    start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply的原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.internal.InlineOnly</span><br><span class="line"><span class="keyword">public</span> inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-with和run"><a href="#3-with和run" class="headerlink" title="3. with和run"></a>3. with和run</h4><p>以后再谈</p><h3 id="四-国际化"><a href="#四-国际化" class="headerlink" title="四. 国际化"></a>四. 国际化</h3><p>找到String.xml文件，点击open editor，点击图标添加一门语言。</p><p>设置文本的默认值和对应语言的值，可以选择是否翻译。</p><p>查看对应的效果需要在手机中将语言改为对应的语言。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/open.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/global.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Kotlin-%E7%AE%80%E5%8D%95%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/settting.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://182.254.228.71/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://182.254.228.71/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>开发工具-Git版本控制-基础知识</title>
    <link href="http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://182.254.228.71/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-07-25T04:10:29.000Z</published>
    <updated>2020-07-25T04:10:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一-起步"><a href="#一-起步" class="headerlink" title="一. 起步"></a>一. 起步</h2><h3 id="1-Mac上安装-GIt"><a href="#1-Mac上安装-GIt" class="headerlink" title="1. Mac上安装 GIt"></a>1. Mac上安装 GIt</h3><p>安装的方式有两种：</p><ul><li>安装Xcode，Xcode自带Git，不建议。</li><li><a href="https://git-scm.com/download/mac">官网下载</a>，建议。</li></ul><p>安装结束后，查看Git的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="2-Git的配置"><a href="#2-Git的配置" class="headerlink" title="2. Git的配置"></a>2. Git的配置</h3><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p><ul><li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。</li><li><code>~/.gitconfig</code> 或 <code>~/.config/git/config</code> 文件：只针对当前用户。</li><li><code>.git/config</code> 文件：当前使用仓库的 Git 目录中的 <code>config</code> 文件，针对该仓库。</li></ul><p>设置用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个东西很重要，多人协作的时候能查看到这些信息</span></span><br><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email 你的邮箱</span><br></pre></td></tr></table></figure><p>查看配置信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/config_list.png" alt=""></p><h4 id="3-获取帮助"><a href="#3-获取帮助" class="headerlink" title="3. 获取帮助"></a>3. 获取帮助</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git help -a</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：git help config</span></span><br><span class="line">git help &lt;verb&gt;</span><br></pre></td></tr></table></figure><h2 id="二-Git基础"><a href="#二-Git基础" class="headerlink" title="二. Git基础"></a>二. Git基础</h2><h3 id="1-获取Git仓库"><a href="#1-获取Git仓库" class="headerlink" title="1. 获取Git仓库"></a>1. 获取Git仓库</h3><h4 id="①-在已有的目录中初始化仓库"><a href="#①-在已有的目录中初始化仓库" class="headerlink" title="① 在已有的目录中初始化仓库"></a>① 在已有的目录中初始化仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>1&gt; 该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p><p>2&gt;<code>.git</code> 的子目录默认看不到，使用<code>Command + Shift + .</code>查看隐藏的文件。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/git_dir.png" alt=""></p><h4 id="②-克隆已有的仓库"><a href="#②-克隆已有的仓库" class="headerlink" title="② 克隆已有的仓库"></a>② 克隆已有的仓库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//克隆path路径的仓库到本地，仓库名和拉取仓库的名相同</span></span><br><span class="line">git clone path</span><br><span class="line"></span><br><span class="line"><span class="comment">//克隆path路径的仓库到本地，仓库名为name</span></span><br><span class="line">git clone path name</span><br></pre></td></tr></table></figure><h3 id="2-Git基础操作"><a href="#2-Git基础操作" class="headerlink" title="2. Git基础操作"></a>2. Git基础操作</h3><h4 id="①-文件状态分类"><a href="#①-文件状态分类" class="headerlink" title="① 文件状态分类"></a>① 文件状态分类</h4><p>请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪（<code>Untracked</code>）或未跟踪（<code>Tracked</code>）。</p><p>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改（<code>Unmodified</code>），已修改（<code>Modified</code>）或已放入暂存区（<code>Staged</code>）。 </p><p>初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/status_graph.png" alt=""></p><h4 id="②-查看文件状态"><a href="#②-查看文件状态" class="headerlink" title="② 查看文件状态"></a>② 查看文件状态</h4><p>1&gt; 如果在克隆仓库后立即使用<code>git status</code>命令，会看到类似这样的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是 “master”,这是默认的分支名。</p><p>2&gt; 如果在刚刚<code>git init</code>的仓库使用此命令，会看到类似这样的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line"><span class="function">nothing to <span class="title">commit</span> <span class="params">(create/copy files and use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure><p>这和上面的说明一致，只不过我们没有提交东西。</p><p>3&gt; 现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)</span><br><span class="line">README.txt</span><br><span class="line"></span><br><span class="line"><span class="function">nothing added to commit but untracked files <span class="title">present</span> <span class="params">(use <span class="string">&quot;git add&quot;</span> to track)</span></span></span><br></pre></td></tr></table></figure><p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围。</p><p>4&gt; 我们使用<code>git add</code>跟踪一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br></pre></td></tr></table></figure><p>此时我们看到看到 README 文件已被跟踪，并处于暂存状态。只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p><p> <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。<code>git add *</code>是追踪所有文件的意思。</p><p>我们尝试创建一个<code>CONTRIBUTING.txt</code>文件，并继续使用<code>git add</code>跟踪一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include in what will be committed)</span><br><span class="line">CONTRIBUTING.txt</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5&gt; 现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 <code>CONTRIBUTING.txt 的已被跟踪的文件，然后运行</code>git status` 命令，会看到下面内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line">modified:   CONTRIBUTING.txt</span><br></pre></td></tr></table></figure><p>文件 <code>CONTRIBUTING.txt</code> 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。</p><p><code>git add</code> 命令：</p><ul><li>开始跟踪新文件</li><li>把已跟踪的文件放到暂存区</li><li>合并时把有冲突的文件标记为已解决状态</li></ul><p>所以将这个命令理解为“添加内容到下一次提交中”。</p><p>此时有一个疑问：CONTRIBUTING.txt` 文件同时出现在暂存区和非暂存区，这是允许的吗？</p><p>实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本， 如果你现在提交，<code>CONTRIBUTING.txt</code> 的版本是你最后一次运行 <code>git add</code> 命令时的那个版本，而不是你运行 <code>git commit</code> 时，在工作目录中的当前版本。 </p><p>所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行<code>git add</code> 把最新版本重新暂存起来。</p><p>现在，解决困惑后，我们运行 <code>git add</code> 命令把已跟踪的文件<code>CONTRIBUTING.txt</code>放到暂存区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br></pre></td></tr></table></figure><p>6&gt; 实际操作截图</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ZSH/git_zsh1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ZSH/git_zsh2.png" alt=""></p><h4 id="③-忽略文件"><a href="#③-忽略文件" class="headerlink" title="③ 忽略文件"></a>③ 忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。</p><p>注意，<code>.gitignore</code>文件需要被纳入 Git 的管理，也就是处于追踪状态才能生效。（创建以<code>.</code>开头的文件会被隐藏的，需要打开隐藏文件）</p><p>我们来看一个实际的例子：</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/gitnore_dir.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看忽略的文件</span></span><br><span class="line">cat .gitignore</span><br><span class="line"></span><br><span class="line">*.c%</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看状态</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   .gitignore</span><br><span class="line"><span class="keyword">new</span> file:   CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br></pre></td></tr></table></figure><p>理论上来说，log.c文件应该会出现在Untracked files下面，但是由于被<code>.gitignore</code>文件列出，所以被忽略了。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式可以以（<code>/</code>）开头防止递归。</li><li>匹配模式可以以（<code>/</code>）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>GitHub 有一个十分详细的针对数十种项目及语言的 <code>.gitignore</code> 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它。</p><h4 id="④-查看已暂存和未暂存的修改"><a href="#④-查看已暂存和未暂存的修改" class="headerlink" title="④ 查看已暂存和未暂存的修改"></a>④ 查看已暂存和未暂存的修改</h4><p>1&gt; 首先我们简单的修改<code>CONTRIBUTING.txt</code>文件，原本它是一个空的，在里面添加<code>hello</code>。使用<code>git status</code>查看得到以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"><span class="keyword">new</span> file:   .gitignore</span><br><span class="line"><span class="keyword">new</span> file:   CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file:   README.txt</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line">modified:   CONTRIBUTING.txt</span><br></pre></td></tr></table></figure><p>2&gt; 使用<code>git diff</code>查看已暂存和未暂存的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/CONTRIBUTING.txt b/CONTRIBUTING.txt</span><br><span class="line">index e69de29..b6fc4c6 <span class="number">100644</span></span><br><span class="line">--- a/CONTRIBUTING.txt</span><br><span class="line">+++ b/CONTRIBUTING.txt</span><br><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span><br><span class="line">+hello</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>3&gt; 使用p4merge作为可视化工具，下载地址：<a href="https://link.jianshu.com/?t=https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">perforce-visual-merge-and-diff-tools</a>。下载到<code>P4V.dmg</code>文件后，双击打开，拖动<code>P4Merge</code>到<code>Application</code>文件夹上就可以完成安装了。</p><p>配置p4merge，输入以下命令即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global diff.tool p4merge</span><br><span class="line">  </span><br><span class="line">git config --global difftool.p4merge.cmd /Applications/p4merge.app/Contents/MacOS/p4merge</span><br><span class="line">  </span><br><span class="line">git config --global difftool.p4merge.cmd <span class="string">&quot;/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE&quot;</span></span><br></pre></td></tr></table></figure><p>4&gt; 使用可视化工具查看已暂存和未暂存的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git difftool</span><br><span class="line">  </span><br><span class="line">Viewing (<span class="number">1</span>/<span class="number">1</span>): <span class="string">&#x27;CONTRIBUTING.txt&#x27;</span></span><br><span class="line">Launch <span class="string">&#x27;p4merge&#x27;</span> [Y/n]? </span><br><span class="line">  </span><br><span class="line"><span class="comment">//输入y即可</span></span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/p4merge_show.png" alt=""></p><p>5&gt; 查看已经暂存起来的变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><h4 id="⑤-提交更新"><a href="#⑤-提交更新" class="headerlink" title="⑤ 提交更新"></a>⑤ 提交更新</h4><p>提交更新的时候请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。</p><p> 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>。</p><p>如果你想一次性提交并写入commit的信息可以使用下面的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit信息&quot;</span></span><br></pre></td></tr></table></figure><p>如果我们在之前的基础上提交，会出现下面的信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[master (root-commit) 1f823c7] 测试</span><br><span class="line"> <span class="number">3</span> files changed, <span class="number">2</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> .gitignore</span><br><span class="line"> create mode <span class="number">100644</span> CONTRIBUTING.txt</span><br><span class="line"> create mode <span class="number">100644</span> README.txt</span><br></pre></td></tr></table></figure><p>当前是在哪个分支（<code>master</code>）提交的，本次提交的完整 SHA-1 校验和是什么（<code>1f823c7</code>），本次提交commit的信息是什么（<code>测试</code>），以及在本次提交中，有多少文件修订过，多少行添加和删改过。</p><p>还有一种直接提交的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line">git commit -a -m <span class="string">&#x27;commit信息&#x27;</span> </span><br></pre></td></tr></table></figure><p>Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p><h4 id="⑥-移除文件"><a href="#⑥-移除文件" class="headerlink" title="⑥ 移除文件"></a>⑥ 移除文件</h4><p>1&gt; 从已跟踪文件清单中移除并连带从工作目录中删除指定的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git rm [path]</span><br><span class="line">  </span><br><span class="line"><span class="comment">//递归删除，适用于删除批量文件</span></span><br><span class="line">git rm [path] -r</span><br><span class="line">  </span><br><span class="line"><span class="comment">//强制删除</span></span><br><span class="line">git rm [path] -f</span><br></pre></td></tr></table></figure><p>删除之后，下一次提交时，该文件就不再纳入版本管理了。</p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>2&gt; 从已跟踪文件清单中移除但是仍然希望保留在当前工作目录中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached [path]</span><br></pre></td></tr></table></figure><h4 id="⑦-重命名文件"><a href="#⑦-重命名文件" class="headerlink" title="⑦ 重命名文件"></a>⑦ 重命名文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git mv file_from file_to</span><br><span class="line">  </span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">mv file_from file_to</span><br><span class="line">git rm file_from</span><br><span class="line">git add file_to</span><br></pre></td></tr></table></figure><h4 id="⑧-查看提交历史"><a href="#⑧-查看提交历史" class="headerlink" title="⑧ 查看提交历史"></a>⑧ 查看提交历史</h4><p>1&gt; 我们可以使用下面的命令回顾提交历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>按提交时间列出所有的更新，最近的更新排在最上面。 </p><p>对我们之前的Test1仓库进行回顾，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit 1f823c7ab4fc9ab44f8480fb18caf8887394f9ad (HEAD -&gt; master)</span><br><span class="line">Author: xulei &lt;<span class="number">2867584387</span><span class="meta">@qq</span>.com&gt;</span><br><span class="line">Date:   Sat Jul <span class="number">25</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">07</span> <span class="number">2020</span> +0800</span><br><span class="line"></span><br><span class="line">    测试</span><br></pre></td></tr></table></figure><p>2&gt; 显示每次提交的内容差异，可以快速浏览某个搭档提交的 commit 所带来的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br><span class="line"></span><br><span class="line"><span class="comment">//仅显示最近两次提交</span></span><br><span class="line">git log -p -<span class="number">2</span></span><br></pre></td></tr></table></figure><p>对我们之前的Test1仓库进行回顾，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">commit 1f823c7ab4fc9ab44f8480fb18caf8887394f9ad (HEAD -&gt; master)</span><br><span class="line">Author: xulei &lt;<span class="number">2867584387</span><span class="meta">@qq</span>.com&gt;</span><br><span class="line">Date:   Sat Jul <span class="number">25</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">07</span> <span class="number">2020</span> +0800</span><br><span class="line"></span><br><span class="line">    测试</span><br><span class="line"></span><br><span class="line">diff --git a/.gitignore b/.gitignore</span><br><span class="line"><span class="keyword">new</span> file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span>.09b2ac1</span><br><span class="line">--- /dev/<span class="keyword">null</span></span><br><span class="line">+++ b/.gitignore</span><br><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span><br><span class="line">+*.c</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/CONTRIBUTING.txt b/CONTRIBUTING.txt</span><br><span class="line"><span class="keyword">new</span> file mode <span class="number">100644</span></span><br><span class="line">index <span class="number">0000000.</span>.b6fc4c6</span><br><span class="line">--- /dev/<span class="keyword">null</span></span><br><span class="line">+++ b/CONTRIBUTING.txt</span><br><span class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</span><br><span class="line">+hello</span><br><span class="line">\ No newline at end of file</span><br><span class="line">diff --git a/README.txt b/README.txt</span><br></pre></td></tr></table></figure><p>3&gt; 查看每次提交的简略的统计信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>对我们之前的Test1仓库进行回顾，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">commit 1f823c7ab4fc9ab44f8480fb18caf8887394f9ad (HEAD -&gt; master)</span><br><span class="line">Author: xulei &lt;<span class="number">2867584387</span><span class="meta">@qq</span>.com&gt;</span><br><span class="line">Date:   Sat Jul <span class="number">25</span> <span class="number">14</span>:<span class="number">40</span>:<span class="number">07</span> <span class="number">2020</span> +0800</span><br><span class="line"></span><br><span class="line">    测试</span><br><span class="line"></span><br><span class="line"> .gitignore       | <span class="number">1</span> +</span><br><span class="line"> CONTRIBUTING.txt | <span class="number">1</span> +</span><br><span class="line"> README.txt       | <span class="number">0</span></span><br><span class="line"> <span class="number">3</span> files changed, <span class="number">2</span> insertions(+)</span><br></pre></td></tr></table></figure><p>4&gt; 指定使用不同于默认格式的方式展示提交历史</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format</span><br></pre></td></tr></table></figure><p>对我们之前的Test1仓库进行回顾，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">  </span><br><span class="line">1f823c7ab4fc9ab44f8480fb18caf8887394f9ad (HEAD -&gt; master) 测试</span><br></pre></td></tr></table></figure><p>format，常用的选项如下：</p><table><thead><tr><th align="left">选项</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>%H</code></td><td align="left">提交对象（commit）的完整哈希字串</td></tr><tr><td align="left"><code>%h</code></td><td align="left">提交对象的简短哈希字串</td></tr><tr><td align="left"><code>%T</code></td><td align="left">树对象（tree）的完整哈希字串</td></tr><tr><td align="left"><code>%t</code></td><td align="left">树对象的简短哈希字串</td></tr><tr><td align="left"><code>%P</code></td><td align="left">父对象（parent）的完整哈希字串</td></tr><tr><td align="left"><code>%p</code></td><td align="left">父对象的简短哈希字串</td></tr><tr><td align="left"><code>%an</code></td><td align="left">作者（author）的名字</td></tr><tr><td align="left"><code>%ae</code></td><td align="left">作者的电子邮件地址</td></tr><tr><td align="left"><code>%ad</code></td><td align="left">作者修订日期（可以用 –date= 选项定制格式）</td></tr><tr><td align="left"><code>%ar</code></td><td align="left">作者修订日期，按多久以前的方式显示</td></tr><tr><td align="left"><code>%cn</code></td><td align="left">提交者（committer）的名字</td></tr><tr><td align="left"><code>%ce</code></td><td align="left">提交者的电子邮件地址</td></tr><tr><td align="left"><code>%cd</code></td><td align="left">提交日期</td></tr><tr><td align="left"><code>%cr</code></td><td align="left">提交日期，按多久以前的方式显示</td></tr><tr><td align="left"><code>%s</code></td><td align="left">提交说明</td></tr></tbody></table><p>给出一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:<span class="string">&quot;%h - %an, %ar : %s&quot;</span></span><br><span class="line">ca82a6d - Scott Chacon, <span class="number">6</span> years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, <span class="number">6</span> years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, <span class="number">6</span> years ago : first commit</span><br></pre></td></tr></table></figure><p>5&gt; 显示 ASCII 图形表示的分支合并历史</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><p>当 oneline 或 format 与另一个 <code>log</code> 选项 <code>--graph</code> 结合使用时尤其有用。 这个选项添加了一些ASCII字符串来形象地展示你的分支、合并历史：</p><p>给出一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:<span class="string">&quot;%h %s&quot;</span> --graph</span><br><span class="line">* 2d3acf9 ignore errors from SIGCHLD on trap</span><br><span class="line">*  5e3ee11 Merge branch <span class="string">&#x27;master&#x27;</span> of git:<span class="comment">//github.com/dustin/grit</span></span><br><span class="line">|\</span><br><span class="line">| * 420eac9 Added a method <span class="keyword">for</span> getting the current branch.</span><br><span class="line">* | 30e367c timeout code and tests</span><br><span class="line">* | 5a09431 add timeout protection to grit</span><br><span class="line">* | e1193f8 support <span class="keyword">for</span> heads with slashes in them</span><br><span class="line">|/</span><br><span class="line">* d6016bc require time <span class="keyword">for</span> xmlschema</span><br><span class="line">*  11d191e Merge branch <span class="string">&#x27;defunkt&#x27;</span> into local</span><br></pre></td></tr></table></figure><h4 id="⑨-撤销，回滚操作"><a href="#⑨-撤销，回滚操作" class="headerlink" title="⑨ 撤销，回滚操作"></a>⑨ 撤销，回滚操作</h4><p>1&gt; 重新提交</p><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p><p>文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。</p><p>给出一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p><p>2&gt; 取消暂存的文件</p><p>例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>根据提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD CONTRIBUTING.md</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">MCONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>3&gt; 撤销对文件的修改</p><p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure><p>根据提示使用 <code>git checkout -- &lt;file&gt;...</code> 来取消暂存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure><p>4&gt; 删除未跟踪文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除 untracked files</span></span><br><span class="line">$ git clean -f</span><br><span class="line">  </span><br><span class="line"><span class="comment">//连 untracked 的目录也一起删除</span></span><br><span class="line">$ git clean -fd</span><br><span class="line">  </span><br><span class="line"><span class="comment">//最强删除</span></span><br><span class="line">$ git clean -xfd</span><br></pre></td></tr></table></figure><p>5&gt; 回滚</p><p>参考：<a href="https://blog.csdn.net/ligang2585116/article/details/71094887">Git撤销&amp;回滚操作</a></p><p>我们将已被提交到“远程仓库”的代码还原操作叫做“回滚”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到要回滚的commitID</span></span><br><span class="line">$ git log</span><br><span class="line">  </span><br><span class="line"><span class="comment">//回滚</span></span><br><span class="line">$ git revert commitID</span><br></pre></td></tr></table></figure><p>删除最后一次远程提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//revert的方式：放弃指定提交的修改，但是会生成一次新的提交，需要填写提交注释，以前的历史记录都在；</span></span><br><span class="line">$ git revert HEAD </span><br><span class="line">$ git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment">//reset的方式：指将HEAD指针指到指定提交，历史记录中不会出现放弃的提交记录。</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line">$ git push origin master -f</span><br></pre></td></tr></table></figure><p>删除某次提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i commit_id</span><br><span class="line"><span class="comment">//再通过将pick改为drop</span></span><br></pre></td></tr></table></figure><p>已在本地进行了多次git commit操作，现在想撤销到其中某次Commit</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset [--soft|mixed（默认）|hard] [commit|HEAD]</span><br></pre></td></tr></table></figure><p>比如本地仓库commit一次（暂且称之为A）：只是提交一个文件（暂且称之为B）</p><ul><li>如果使用 git reset – soft  A回滚版本，A提交没有了，B文件处于未提交状态。</li><li>如果使用 git reset – mixed A回滚版本，A提交没有了，B文件处于未暂存状态。</li><li>如果使用 git reset – hard A回滚版本，A提交没有了，B文件不存在了。</li></ul><p>具体的使用参考文章—<a href="https://www.jianshu.com/p/cbd5cd504f14">Git reset命令的使用</a></p><h2 id="三-远程仓库的使用"><a href="#三-远程仓库的使用" class="headerlink" title="三. 远程仓库的使用"></a>三. 远程仓库的使用</h2><p>前提：我在我自己的Gitlab上创建了一个空的项目。</p><h3 id="1-查看远程仓库"><a href="#1-查看远程仓库" class="headerlink" title="1. 查看远程仓库"></a>1. 查看远程仓库</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先将远程仓库克隆到本地</span></span><br><span class="line">git clone git<span class="meta">@gitlab</span>.com:xuxiaoshi/test.git</span><br></pre></td></tr></table></figure><p>①  <code>git remote</code> 命令会列出你指定的每一个远程服务器的简写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>如果显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL，使用下面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origingit<span class="meta">@gitlab</span>.com:xuxiaoshi/test.git (fetch)</span><br><span class="line">origingit<span class="meta">@gitlab</span>.com:xuxiaoshi/test.git (push)</span><br></pre></td></tr></table></figure><h3 id="2-添加远程仓库"><a href="#2-添加远程仓库" class="headerlink" title="2. 添加远程仓库"></a>2. 添加远程仓库</h3><p>添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>给出一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add test_add https:<span class="comment">//gitlab.com/xuxiaoshi/test_add.git</span></span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origingit<span class="meta">@gitlab</span>.com:xuxiaoshi/test.git (fetch)</span><br><span class="line">origingit<span class="meta">@gitlab</span>.com:xuxiaoshi/test.git (push)</span><br><span class="line">test_addhttps:<span class="comment">//gitlab.com/xuxiaoshi/test_add.git (fetch)</span></span><br><span class="line">test_addhttps:<span class="comment">//gitlab.com/xuxiaoshi/test_add.git (push)</span></span><br></pre></td></tr></table></figure><h3 id="3-删除一个远程仓库以及重命名"><a href="#3-删除一个远程仓库以及重命名" class="headerlink" title="3. 删除一个远程仓库以及重命名"></a>3. 删除一个远程仓库以及重命名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除一个远程仓库</span></span><br><span class="line">git remote rm &lt;shortname&gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//重命名一个远程仓库</span></span><br><span class="line">git remote rename &lt;shortname&gt; &lt;new_shortname&gt;</span><br></pre></td></tr></table></figure><h2 id="四-打标签"><a href="#四-打标签" class="headerlink" title="四. 打标签"></a>四. 打标签</h2><h3 id="1-列出Tag"><a href="#1-列出Tag" class="headerlink" title="1. 列出Tag"></a>1. 列出Tag</h3><p>以字母顺序列出标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h3 id="2-创建Tag"><a href="#2-创建Tag" class="headerlink" title="2. 创建Tag"></a>2. 创建Tag</h3><p>一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。</p><p>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p><h4 id="①-轻量标签（lightweight）"><a href="#①-轻量标签（lightweight）" class="headerlink" title="① 轻量标签（lightweight）"></a>① 轻量标签（lightweight）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt;</span><br></pre></td></tr></table></figure><h4 id="②-附注标签（annotated）"><a href="#②-附注标签（annotated）" class="headerlink" title="② 附注标签（annotated）"></a>② 附注标签（annotated）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;name&gt; -m <span class="string">&#x27;信息&#x27;</span></span><br></pre></td></tr></table></figure><p><code>-m</code> 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。</p><h3 id="3-查看Tag对应的信息"><a href="#3-查看Tag对应的信息" class="headerlink" title="3.查看Tag对应的信息"></a>3.查看Tag对应的信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;tag&gt;</span><br></pre></td></tr></table></figure><h2 id="五-Git分支"><a href="#五-Git分支" class="headerlink" title="五. Git分支"></a>五. Git分支</h2><h3 id="1-分支简介"><a href="#1-分支简介" class="headerlink" title="1. 分支简介"></a>1. 分支简介</h3><p>在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p><p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p><blockquote><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p></blockquote><h3 id="2-分支的创建，删除和合并"><a href="#2-分支的创建，删除和合并" class="headerlink" title="2.分支的创建，删除和合并"></a>2.分支的创建，删除和合并</h3><h4 id="①-分支的创建"><a href="#①-分支的创建" class="headerlink" title="① 分支的创建"></a>① 分支的创建</h4><p>1&gt; Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。使用下面的命令就可以创建分支了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p>2&gt; Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支。</p><h4 id="②-分支切换"><a href="#②-分支切换" class="headerlink" title="② 分支切换"></a>② 分支切换</h4><p>要切换到一个已存在的分支（实际上就是更改<code>HEAD</code> 指针的指向），你需要使用以下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p>有时候也许你想在创建分支的时候就切换到创建的分支，你可以使用下面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure><h4 id="③-分支删除"><a href="#③-分支删除" class="headerlink" title="③ 分支删除"></a>③ 分支删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br></pre></td></tr></table></figure><h4 id="④-分支合并"><a href="#④-分支合并" class="headerlink" title="④ 分支合并"></a>④ 分支合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据给的分支名更新当前分支的内容</span></span><br><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/merge.png" alt=""></p><p>1&gt; 如上图所示，如果你想将hotfix分支的内容合并到master分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">git merge hotfix</span><br></pre></td></tr></table></figure><p>合并的时候会出现<code>Fast-forward</code>，这是因为当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/merge1.png" alt="i"></p><p>2&gt; 如下图所示，如果你想将iss53分支的内容合并到master分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge iss53</span><br></pre></td></tr></table></figure><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/merge3.png" alt=""></p><p>在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/merge2.png" alt=""></p><p>3&gt; 上面的合并不可能一直很顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。</p><p>你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突。等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决。</p><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。</p><p>下载好后，配置p4merge作为我们解决merge冲突时的可视化工具。参考文章：<a href="https://gist.github.com/tony4d/3454372">p4merge合并问题</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool p4mergetool</span><br><span class="line">  </span><br><span class="line">$ git config --global mergetool.p4mergetool.cmd \</span><br><span class="line"><span class="string">&quot;/Applications/p4merge.app/Contents/Resources/launchp4merge \$PWD/\$BASE \$PWD/\$REMOTE \$PWD/\$LOCAL \$PWD/\$MERGED&quot;</span></span><br><span class="line">  </span><br><span class="line">$ git config --global mergetool.p4mergetool.trustExitCode <span class="keyword">false</span></span><br><span class="line">  </span><br><span class="line">$ git config --global mergetool.keepBackup <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>如果你正在合并中，你可以使用下面的命令结束合并：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure><h4 id="⑤-查看分支"><a href="#⑤-查看分支" class="headerlink" title="⑤ 查看分支"></a>⑤ 查看分支</h4><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch &#x27;iss53&#x27;</span><br></pre></td></tr></table></figure><h3 id="3-远程分支"><a href="#3-远程分支" class="headerlink" title="3. 远程分支"></a>3. 远程分支</h3><p>前提：拉取Gitlab上的Test仓库到本地</p><h4 id="①关于分支"><a href="#①关于分支" class="headerlink" title="①关于分支"></a>①关于分支</h4><p>1&gt; 默认本地master分支和origin/master分支绑定在一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">  </span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>创建本地分支 映射想要映射的远程分支，并切换到创建的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 本地分支名x origin&#x2F;远程分支名x</span><br></pre></td></tr></table></figure><p>关于映射关系可以参考这篇文章：<a href="https://blog.csdn.net/tterminator/article/details/78108550">Git branch upstream</a></p><p>2&gt; 切换绑定的远程分支或者创建远程分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream &lt;remote-name&gt; &lt;local-branch-name&gt;:&lt;remote-branch-name&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;remote-name&gt;</code>：远程git服务器名称，一般设为origin</p></li><li><p><code>&lt;local-branch-name&gt;</code>：本地分支名称</p></li><li><p><code>&lt;remote-branch-name&gt;</code>：远程分支名称</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git push --set-upstream origin master:test</span><br><span class="line"></span><br><span class="line">remote:</span><br><span class="line">remote: INFO: Your SSH key has expired. Please generate a <span class="keyword">new</span> key.</span><br><span class="line">remote:</span><br><span class="line">Total <span class="number">0</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote:</span><br><span class="line">remote: To create a merge request <span class="keyword">for</span> test, visit:</span><br><span class="line">remote:   https:<span class="comment">//gitlab.com/xuxiaoshi/test/-/merge_requests/new?merge_request%5Bsource_branch%5D=test</span></span><br><span class="line">remote:</span><br><span class="line">To gitlab.com:xuxiaoshi/test.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; test</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> set up to track remote branch <span class="string">&#x27;test&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure><p>3&gt; 删除远程分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete 远程分支名</span><br></pre></td></tr></table></figure><p>例如删除刚才创建的远程分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --delete test</span><br><span class="line">  </span><br><span class="line"><span class="comment">//这样子需要注意，我们本地分支是绑定远程的test分支，删除后，需要记得重新绑定</span></span><br></pre></td></tr></table></figure><p>4&gt; 查看所有的分支，包括远程分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">  </span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure><h4 id="②-分支合并"><a href="#②-分支合并" class="headerlink" title="② 分支合并"></a>② 分支合并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推送本地分支到远程，之后需要merge request</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉取远程分支到本地</span></span><br><span class="line">git fetch</span><br><span class="line">  </span><br><span class="line"><span class="comment">//拉取远程分支到本地并合并</span></span><br><span class="line"><span class="function">git <span class="title">pull</span> <span class="params">(git fetch &amp; git merge)</span> </span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">//如果git pull出现冲突，放弃本地修改，使远程库内容强制覆盖本地代码</span></span></span><br><span class="line"><span class="function">git fetch --all</span></span><br><span class="line"><span class="function">git reset --hard origin/<span class="title">master</span><span class="params">(你自己绑定的远端分支)</span></span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u014515854/article/details/80842249">git pull时遇到error: cannot lock ref ‘xxx’: ref xxx is at （一个commitID） but expected的解决办法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的建议</span></span><br><span class="line">git reset --hard origin/master(你自己绑定的远端分支)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//参考文章的做法</span></span><br><span class="line">git update-ref -d refs/remotes/origin/feature/calidge-adapter <span class="comment">// 删除出问题的ref</span></span><br><span class="line">git pull origin feature/calidge-adapter  <span class="comment">//重新pull</span></span><br><span class="line">git reset --hard origin/feature/calidge-adapter   <span class="comment">//出现冲突，强制覆盖</span></span><br></pre></td></tr></table></figure><h3 id="4-变基"><a href="#4-变基" class="headerlink" title="4. 变基"></a>4. 变基</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/merge3.png" alt="i"></p><p>之前介绍过，整合分支最容易的方法是 <code>merge</code> 命令。 它会把两个分支的最新快照（<code>C3</code> 和 <code>C4</code>）以及二者最近的共同祖先（<code>C2</code>）进行三方合并，合并的结果是生成一个新的快照（并提交）。</p><p>其实，还有一种方法：你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在 <code>C3</code> 的基础上应用一次。 在 Git 中，这种操作就叫做 <em>变基</em>。 你可以使用 <code>rebase</code> 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</p><p>在上面这个例子中，运行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git rebase iss53</span><br></pre></td></tr></table></figure><p>它的原理是首先找到这两个分支（即当前分支 <code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先 <code>C2</code>，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>C3</code>, 最后以此将之前另存为临时文件的修改依序应用。之后，进行一次快进合并。</p><h2 id="六-命令合集"><a href="#六-命令合集" class="headerlink" title="六. 命令合集"></a>六. 命令合集</h2><p>参考：<a href="https://blog.csdn.net/jtracydy/article/details/70402663">git命令-远程仓库拉取、本地仓库更新、工作空间提交等等</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.progit.cn/#_pro_git">Pro Git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://182.254.228.71/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式-命令模式</title>
    <link href="http://182.254.228.71/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://182.254.228.71/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-04T10:36:19.000Z</published>
    <updated>2020-07-04T10:36:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考：<a href="https://www.jianshu.com/p/ff909f9d925f">Android的设计模式-命令模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android设计模式" scheme="http://182.254.228.71/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式-享元模式</title>
    <link href="http://182.254.228.71/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://182.254.228.71/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-07-04T10:36:13.000Z</published>
    <updated>2020-07-04T10:36:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考：<a href="https://www.jianshu.com/p/1dc997737dd3">Android的设计模式-享元模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android设计模式" scheme="http://182.254.228.71/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：其它优化</title>
    <link href="http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96/"/>
    <id>http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-04T10:34:35.000Z</published>
    <updated>2020-07-04T10:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一-TraceView"><a href="#一-TraceView" class="headerlink" title="一. TraceView"></a>一. TraceView</h4><h3 id="二-Lint"><a href="#二-Lint" class="headerlink" title="二. Lint"></a>二. Lint</h3><h3 id="三-轻量容器"><a href="#三-轻量容器" class="headerlink" title="三. 轻量容器"></a>三. 轻量容器</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96/other1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%85%B6%E5%AE%83%E4%BC%98%E5%8C%96/other2.png" alt=""></p><h3 id="四-Other"><a href="#四-Other" class="headerlink" title="四. Other"></a>四. Other</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android性能优化" scheme="http://182.254.228.71/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：Bitmap优化</title>
    <link href="http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/"/>
    <id>http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-04T10:34:26.000Z</published>
    <updated>2020-07-04T10:34:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-Bitmap-decode"><a href="#一-Bitmap-decode" class="headerlink" title="一. Bitmap decode"></a>一. Bitmap decode</h3><p>常见的jpg，png，webp是图像的存储格式</p><p>Android要显示图片必须经过解码（decode）读取图像的数据到内存中</p><p>BitmapFactory提供了常用的一些decode方法</p><p>图片真正占用的内存要看decode之后的数据大小</p><h3 id="二-Bitmap-memory"><a href="#二-Bitmap-memory" class="headerlink" title="二. Bitmap memory"></a>二. Bitmap memory</h3><h4 id="1-lt-2-3-（API-10）"><a href="#1-lt-2-3-（API-10）" class="headerlink" title="1. &lt;= 2.3 （API 10）"></a>1. &lt;= 2.3 （API 10）</h4><ul><li>Bitmap解码之后的数据存储在Native Memory中</li><li>手动调用Recycle回收</li></ul><h4 id="2-gt-3-0（API-11）"><a href="#2-gt-3-0（API-11）" class="headerlink" title="2. &gt;= 3.0（API 11）"></a>2. &gt;= 3.0（API 11）</h4><ul><li>Bitmap解码之后的数据存储在Dalvik heap中</li><li>Dalvik自动回收</li></ul><h3 id="三-Reusing-Bitmap"><a href="#三-Reusing-Bitmap" class="headerlink" title="三. Reusing Bitmap"></a>三. Reusing Bitmap</h3><h4 id="1-复用Bitmap"><a href="#1-复用Bitmap" class="headerlink" title="1. 复用Bitmap"></a>1. 复用Bitmap</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse2.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse3.png" alt=""></p><h4 id="2-Bitmap对象池"><a href="#2-Bitmap对象池" class="headerlink" title="2. Bitmap对象池"></a>2. Bitmap对象池</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse4.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse5.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_reuse6.png" alt=""></p><h4 id="3-开源工具"><a href="#3-开源工具" class="headerlink" title="3. 开源工具"></a>3. 开源工具</h4><p><a href="https://github.com/bumptech/glide">Glide</a></p><h3 id="四-Pre-scaling-Bitmap"><a href="#四-Pre-scaling-Bitmap" class="headerlink" title="四. Pre-scaling Bitmap"></a>四. Pre-scaling Bitmap</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale2.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale3.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale4.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale5.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_scale6.png" alt=""></p><h3 id="五-Smaller-Pixel-Format"><a href="#五-Smaller-Pixel-Format" class="headerlink" title="五. Smaller Pixel Format"></a>五. Smaller Pixel Format</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_format1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_format2.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_format3.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_format4.png" alt=""></p><h3 id="六-LRU-cache"><a href="#六-LRU-cache" class="headerlink" title="六. LRU cache"></a>六. LRU cache</h3><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_lru1.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_lru2.png" alt=""></p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E4%BC%98%E5%8C%96/bitmap_lru3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android性能优化" scheme="http://182.254.228.71/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：电量优化</title>
    <link href="http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    <id>http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-04T10:34:17.000Z</published>
    <updated>2020-07-04T10:34:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h3><p>​       耗电情况，例如：打开屏幕，所有要使用CPU/GPU工作的动作都会唤醒屏幕，都会消耗电量。这和应用程序唤醒设备还不一样。比如使用叫醒闹钟(wake clock)、AlarmManager、JobSchedulerAPI。</p><h3 id="二-电量消耗情景"><a href="#二-电量消耗情景" class="headerlink" title="二. 电量消耗情景"></a>二. 电量消耗情景</h3><h4 id="1-移动网络请求"><a href="#1-移动网络请求" class="headerlink" title="1. 移动网络请求"></a>1. 移动网络请求</h4><p>当设备通过无线网发送数据的时候，为了使用硬件，这里会出现一个唤醒耗电高峰。接下来还 有一个高数值，这是发送数据包消耗的电量，然后接受数据包也会消耗大量电量 也看到一个峰值。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/dian.png" alt=""></p><h4 id="2-WakeLock"><a href="#2-WakeLock" class="headerlink" title="2. WakeLock"></a>2. WakeLock</h4><p>Android 系统本身为了优化电量的使用，会在没有操作时进入休眠状态，来节省电量。当然，为了便于开发(很多应用不可避免的希望在灭屏后还能运行一些事儿，或是要保持屏幕一直亮着–比如播放视频)，Android 提供了一个 PowerManager.WakeLock 的东西。</p><p>我们可以用 WakeLock 来保持 CPU 运行，或是防止屏幕变暗/关闭，让手机可以在用户不操作时依然可以做一些事儿。然而，获取 WakeLock 很容易，释放不好就会成为难题，消耗电量。例如获取了一个 WakeLock 来保持 CPU 运转，做一个复杂运算并将数据上传到后台服务器，然后释放该 WakeLock。然而这个过程可能并不像我们想象的那么快，可能因为比如服务器挂掉，计算出了异常等等导致 WakeLock 没有释放，CPU 会一直得不到休眠，而大大增加耗电。</p><h4 id="3-GPS"><a href="#3-GPS" class="headerlink" title="3. GPS"></a>3. GPS</h4><p>应用中经常会用到定位服务，Android 提供了 Network 定位和 GPS 定位。相对来说，GPS 会精确得多，对于一些诸如跑步，导航类的应用基本会使用 GPS 定位。然而，GPS 定位也会消耗大量的电量。</p><h3 id="二-电量分析工具"><a href="#二-电量分析工具" class="headerlink" title="二. 电量分析工具"></a>二. 电量分析工具</h3><h4 id="Battery-History-工具"><a href="#Battery-History-工具" class="headerlink" title="Battery History 工具"></a>Battery History 工具</h4><p>要进行电量优化，我们首先得知道电都消耗到哪里去了，我们可以通过 google 开源的 Battery-Historian 来进行分析。</p><p>工具开源地址: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fgoogle%2Fbattery-historian">https://github.com/google/battery-historian</a></p><h3 id="三-优化措施"><a href="#三-优化措施" class="headerlink" title="三. 优化措施"></a>三. 优化措施</h3><h4 id="1-优化网络请求"><a href="#1-优化网络请求" class="headerlink" title="1. 优化网络请求"></a>1. 优化网络请求</h4><p>在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。</p><p>尽量在 Wi-Fi 环境下使用数据传输。</p><h4 id="2-谨慎使用WakeLock"><a href="#2-谨慎使用WakeLock" class="headerlink" title="2. 谨慎使用WakeLock"></a>2. 谨慎使用WakeLock</h4><p>WakeLock 获取释放成对出现（调用 release），使用超时 WakeLock，以防出异常导致没有释放。</p><p>WakeLock 有一个接口 setReferenceCounted，用来设置 WakeLock 的计数机制，true 为计数，false 为不计数，默认是 true。所谓计数即每一个 acquire 必须对应一个 release；不计数则是无论有多少个 acquire，一个 release 就可以释放。虽然官方说默认 是计数的，但有的第三方 ROM 做了修改，使默认是不计数的。</p><p>主动设置 <code>wakeLock.setReferenceCounted(false)</code>。</p><h4 id="3-监听手机充电状态"><a href="#3-监听手机充电状态" class="headerlink" title="3. 监听手机充电状态"></a>3. 监听手机充电状态</h4><p>BatteryManager 会发送一个包含充电状态的持续广播，我们可以通过此广播获取充电状态和电量详情。因为这是一个持续广播，无需写 Receiver，可以直接通过 intent 获取相关数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter ifilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">Intent batteryStatus = context.registerReceiver(<span class="keyword">null</span>，ifilter);</span><br><span class="line"><span class="comment">// 设备正在充电</span></span><br><span class="line"><span class="keyword">int</span> status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS，-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||</span><br><span class="line">                 status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line"><span class="comment">// 也可以监听充电状态的变化，只要设备连接或断开电源，BatteryManager 就会广播相应的操作</span></span><br><span class="line"><span class="keyword">int</span> chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED，-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> usbCharge = chargePlug == BATTERY_PLUGGED_USB;</span><br><span class="line"><span class="keyword">boolean</span> acCharge = chargePlug == BATTERY_PLUGGED_AC;</span><br></pre></td></tr></table></figure><p>另外页可以注册 Receiver来监听</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.PowerConnectionReceiver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.ACTION_POWER_CONNECTED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.ACTION_POWER_DISCONNECTED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-Doze-and-App-Standby"><a href="#4-Doze-and-App-Standby" class="headerlink" title="4. Doze and App Standby"></a>4. Doze and App Standby</h4><p>Android 6.0 提供了两个用来节省电量的技术 Doze 和 App Standby。</p><ul><li>Doze 瞌睡。如果设备闲置了一段较长时间，Doze 技术将通过延迟后台网络活动，CPU 运行等来减少电量损耗。</li><li>App Standy 应用待机。不是最近得到过用户使用的 App，App Standy 将延缓这个应用的后台网络活动。</li></ul><p>所有 Android 6.0 及以上的设备上，Doze and App Standby 都会运行。可能会影响 App 的运行，可以根据官方文档适配。</p><p>可以在代码中调起电量优化的设计页面，让用户选择是否将应用加入白名单，以在 Doze 模式下能够做一些事情。</p><h4 id="5-定位中使用-GPS，及时关闭"><a href="#5-定位中使用-GPS，及时关闭" class="headerlink" title="5. 定位中使用 GPS，及时关闭"></a>5. 定位中使用 GPS，及时关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove the listener you previously added</span></span><br><span class="line">locationManager.removeUpdates(locationListener);</span><br></pre></td></tr></table></figure><h4 id="6-计算优化"><a href="#6-计算优化" class="headerlink" title="6. 计算优化"></a>6. 计算优化</h4><p>缩短代码产生指令运行的时间，进而减少某个应用程序对 CPU 时间片 的总占用时间，进而减少单位时间内该应用程序占整个系统耗电的百分比。</p><p>浮点运算比整数运算更消耗 CPU 时间片，因此耗电也会增加，在编写 代码的过程中应该尽量减少浮点运算。</p><ul><li>除法变乘法。</li><li>充分利用移位。</li><li>查表法，直接使用映射关系，但这会增加内存占用，视情况而定。</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><p>熄屏后停止一些和 UI 效果有关的操作，比如动画。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><strong><a href="https://www.jianshu.com/p/627554db9f60">Android 优化——电量优化</a></strong></p><p><strong><a href="https://www.jianshu.com/p/c86021fe958d">Android电量优化全解析</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android性能优化" scheme="http://182.254.228.71/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：布局优化</title>
    <link href="http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/"/>
    <id>http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-04T10:34:07.000Z</published>
    <updated>2020-07-04T10:34:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-过度绘制"><a href="#一-过度绘制" class="headerlink" title="一. 过度绘制"></a>一. 过度绘制</h3><h4 id="1-什么是过度绘制"><a href="#1-什么是过度绘制" class="headerlink" title="1. 什么是过度绘制"></a>1. 什么是过度绘制</h4><p>一个像素绘制超过一次。</p><h4 id="2-追踪过度绘制"><a href="#2-追踪过度绘制" class="headerlink" title="2. 追踪过度绘制"></a>2. 追踪过度绘制</h4><p>Android手机的开发者模式有一个Show GPU Overdraw工具。</p><ul><li>蓝色：1×过度绘制。</li><li>绿色：2×过度绘制。</li><li>浅红色：3×过度绘制。</li><li>深红色：4×过度绘制。</li></ul><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/overdraw_find.png" alt=""></p><h4 id="3-优化过度绘制"><a href="#3-优化过度绘制" class="headerlink" title="3. 优化过度绘制"></a>3. 优化过度绘制</h4><p>降低View层级：</p><ul><li>LinearLayout VS RelativeLayout</li><li>merge</li></ul><p>不必要的背景：</p><ul><li>去掉window的背景</li><li>去掉布局中不必要的背景。</li></ul><p>ClipRect &amp; QuickReject</p><p>ViewStub</p><p>.9图用作背景</p><h3 id="二-UI卡顿"><a href="#二-UI卡顿" class="headerlink" title="二.UI卡顿"></a>二.UI卡顿</h3><h4 id="1-帧率"><a href="#1-帧率" class="headerlink" title="1.帧率"></a>1.帧率</h4><p>Frame Rate，单位fps，是指GPU生成帧的速率，越高越好。</p><h4 id="2-屏幕刷新率"><a href="#2-屏幕刷新率" class="headerlink" title="2. 屏幕刷新率"></a>2. 屏幕刷新率</h4><p>Refresh Rate，单位HZ，是指设备刷新屏幕的频率，对于特定设备来说是个常量，如60HZ。</p><h4 id="3-VSync的作用"><a href="#3-VSync的作用" class="headerlink" title="3. VSync的作用"></a>3. VSync的作用</h4><p>① 没有引入VSync时，屏幕显示图像的工作流程。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/vsync_1.png" alt=""></p><p>如上图，CPU/GPU 向 Buffer 中生成图像，屏幕从 Buffer 中取图像、刷新后显示。这是一个典型的生产者——消费者模型。<br>理想的情况是帧率和刷新频率相等，每绘制一帧，屏幕显示一帧。而实际情况是，二者之间没有必然的大小关系，如果没有锁来控制同步，很容易出现问题。例如，当帧率大于刷新频率，当屏幕还没有刷新第 n-1 帧的时候，GPU 已经在生成第 n 帧了，从上往下开始覆盖第 n-1 帧的数据，当屏幕开始刷新第 n-1 帧的时候，Buffer 中的数据上半部分是第 n 帧数据，而下半部分是第 n-1 帧的数据，显示出来的图像就会出现上半部分和下半部分明显偏差的现象，我们称之为 “tearing”。</p><p>② 双重缓存</p><p>为了解决单缓存的“tearing”问题，双重缓存和 VSync 应运而生。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/vsync_2.png" alt=""></p><p>工作流程这样的：<br>在某个时间点，一个屏幕刷新周期完成，进入短暂的刷新空白期。此时，VSync 信号产生，先完成复制操作，然后通知 CPU/GPU 绘制下一帧图像。复制操作完成后屏幕开始下一个刷新周期，即将刚复制到 Frame Buffer 的数据显示到屏幕上。</p><p>在这种模型下，只有当 VSync 信号产生时，CPU/GPU 才会开始绘制。这样，当帧率大于刷新频率时，帧率就会被迫跟刷新频率保持同步，从而避免“tearing”现象。</p><p>③ 三重缓存</p><p>略</p><h4 id="4-避免UI卡顿"><a href="#4-避免UI卡顿" class="headerlink" title="4.  避免UI卡顿"></a>4.  避免UI卡顿</h4><ul><li>避免onDraw中创建对象，对象池。</li><li>减少View层级</li><li>避免在UI顶层使用ReleativeLayout，measure两次</li><li>自定义View控制绘制的复杂度</li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/zhaizu/article/details/51882768#%E5%B8%A7%E7%8E%87-vs-%E5%B1%8F%E5%B9%95%E5%88%B7%E6%96%B0%E9%A2%91%E7%8E%87">理解 VSync</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android性能优化" scheme="http://182.254.228.71/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>面试-字节跳动Android实习生</title>
    <link href="http://182.254.228.71/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Android%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    <id>http://182.254.228.71/%E9%9D%A2%E8%AF%95-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8Android%E5%AE%9E%E4%B9%A0%E7%94%9F/</id>
    <published>2020-07-04T09:42:43.000Z</published>
    <updated>2020-07-04T09:42:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h3><p>本人末流211计算机专业大三本科生，于2020年6月20日在字节跳动的官网上投递了广州的Android开发实习生。</p><p>字节跳动的面试官真的很nice，特别有耐心。</p><h3 id="一面（6月24日-104min）"><a href="#一面（6月24日-104min）" class="headerlink" title="一面（6月24日 104min）"></a>一面（6月24日 104min）</h3><ul><li><p>自我介绍。</p></li><li><p>线程和进程的区别。</p></li><li><p>线程安全。我回答了sychronized关键字（关于锁，wait，notify参考我的一篇博客—<a href="https://www.jianshu.com/p/76c6b75efcc5">Java 多线程</a>）。面试官追问是否了解volite关键字，我忘了没回答出来。面试官追问是否了解自旋锁，乐观锁，悲观锁等，我回答了解但是没用过。</p></li><li><p>http是用什么实现的。</p></li><li><p>TCP和UDP的区别。</p></li><li><p>TCP为什么是可靠的。注意拥塞机制涉及的算法（慢开始，拥塞避难，快重传，快恢复）。</p></li><li><p>Get请求和Post请求的区别。注意Get请求比Post请求效率高，Post请求需要服务器返回100再发送数据处理，Get请求直接是通过URL。面试官追问是否知道其他请求方式，Put，Delete，Head。</p></li><li><p>项目中询问一个 A Activity 跳到一个 B Activity中，生命周期的走动，点击Back返回呢。如果一个 A Activity是透明的呢？如果 B Activity是一个Dialog呢？面试官追问横竖屏切换生命周期走动，以及是否了解onConfigurationChanged。</p></li><li><p>HashMap的源码，扩容的条件。</p></li><li><p>算法两道，一道是和并两个有序链表，我用的归并排序合并过程的思路写的（长时间用IDE，好多错误，但是面试官很有耐心帮我纠错）。一道是思路，将一段文本中的单词逆序输出，主要考察数据结构的知识，用到了栈和队列。</p></li><li><p>询问我的基本情况，实习时间等。</p></li><li><p>反问环节：其实没问，面试官建议我对常见的知识做深一步的理解，多看源码，多用记事本写代码，多看看基本的数据结构和算法。</p></li></ul><h3 id="二面（7月1日-57min）"><a href="#二面（7月1日-57min）" class="headerlink" title="二面（7月1日 57min）"></a>二面（7月1日 57min）</h3><ul><li>自我介绍。</li><li>说说自己的亮点，我说了写博客。</li><li>Android静态库和动态库的区别。</li><li>Android中Binder机制。</li><li>Android进程间的通信。</li><li>说说自旋锁，内部实现。</li><li>问了线程同步，我又说了sychroized，还是参考那篇博客。</li><li>设计模式六大原则，给出具体情况，应该怎么做。</li><li>是否了解Java的atomic，以及好多很底层的东西，记不清了，大部分都没有回答出来。</li><li>算法题：求解矩形起点到终点的最短路径，只能向右或者向下走，这是一道简单的动态规划题。</li><li>询问我的基本情况，实习时间等。</li><li>反问环节：询问自己想要加入还需要提升那部分的知识，面试官建议多参加实际的项目。</li></ul><h3 id="三面（7月3日-40min）"><a href="#三面（7月3日-40min）" class="headerlink" title="三面（7月3日 40min）"></a>三面（7月3日 40min）</h3><ul><li><p>自我介绍。</p></li><li><p>项目中出现的难处以及解决。我说的是我使用addView达到弹出框的效果，但是耗时长。后来了解Fragment，使用Fragment代替addView。面试官追问你能分析为什么这么慢吗，我就说了Android的Activity-&gt;PhoneWindow-&gt;DecorView-&gt;ContentView-&gt;WindowManager-&gt;RootViewImpl的绘制流程。面试官继续追问ANR出现的类型，原因以及排查的方式。面试官继续追问Fragment和Activity的区别以及Fragment的优点。</p></li><li><p>说一下Android中多线程使用方式。面试官追问如何停止一个线程。</p></li><li><p>Handler的原理。Looper，MessageQueue，Message。面试官追问在一个Handler中给另一个Handler发送消息，我没太理解其实。</p></li><li><p>Java内存，回收的搜索算法：引用计数和根搜索算法。</p></li><li><p>算法题：将一个32位的int型整数逆序，我用的取整加取余获取每一位保存在链表中，然后反转链表。</p></li><li><p>询问我的基本情况，实习时间，职业规划等。</p></li></ul><h3 id="Hr面（7月3日-20min）"><a href="#Hr面（7月3日-20min）" class="headerlink" title="Hr面（7月3日 20min）"></a>Hr面（7月3日 20min）</h3><ul><li><p>自我介绍。</p></li><li><p>询问我的基本情况，实习时间，职业规划等。</p></li><li><p>给了口头Offer。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="面试" scheme="http://182.254.228.71/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://182.254.228.71/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：内存优化</title>
    <link href="http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://182.254.228.71/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-22T02:34:49.000Z</published>
    <updated>2020-06-22T02:34:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-垃圾回收机制"><a href="#一-垃圾回收机制" class="headerlink" title="一. 垃圾回收机制"></a>一. 垃圾回收机制</h3><h4 id="1-什么是垃圾回收机制"><a href="#1-什么是垃圾回收机制" class="headerlink" title="1. 什么是垃圾回收机制"></a>1. 什么是垃圾回收机制</h4><p>自动内存管理和回收机制。垃圾回收器负责回收程序中已经不使用，但是仍然被各种对象占用的内存。</p><p>优点：将程序员从繁重，危险的内存管理工作中解放出来。</p><p>缺点：可能会占用大量资源。</p><h4 id="2-Android中的垃圾回收机制"><a href="#2-Android中的垃圾回收机制" class="headerlink" title="2. Android中的垃圾回收机制"></a>2. Android中的垃圾回收机制</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/laji_show.png" alt=""></p><p><strong>Young Generation</strong></p><ul><li>大多数新建的对象都位于Eden区。</li><li>当EDen区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到一个survivor区。</li><li>Survivor Space：S0，S1有两个，存放每次垃圾回收后存活的对象。</li><li>MInor GC同样会检查survivor区中存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。</li></ul><p><strong>Old Generation</strong></p><ul><li>存放长期存活的对象和经过多次MInor GC后依然存活下来的对象。</li><li>满了进行Major GC。</li></ul><p><strong>Permanent Generation</strong></p><ul><li>存放方法区，方法区中有要加载的类信息，静态变量，final类型的常量，属性和方法信息。</li></ul><h4 id="3-垃圾回收机制-amp-FPS"><a href="#3-垃圾回收机制-amp-FPS" class="headerlink" title="3. 垃圾回收机制 &amp; FPS"></a>3. 垃圾回收机制 &amp; FPS</h4><ul><li>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，那么整个过程如果保证在16ms以内就能达到一个流畅的画面。60FPS</li><li>如果某一帧的操作超过了16ms就会让用户感觉到卡顿。</li><li>UI渲染过程发生GC，导致某一帧绘制时间超过16ms。</li></ul><h3 id="二-内存泄漏"><a href="#二-内存泄漏" class="headerlink" title="二. 内存泄漏"></a>二. 内存泄漏</h3><p>在整个Android开发过程中，内存泄漏是导致OOM（Out Of Memory内存溢出）的一个重要因素。</p><p>当出现以下情况就会发生卡顿。</p><ul><li>应用程序分配了大量不能回收的对象。</li><li>这导致可分配的内存越来越少。</li><li>当新对象的创建需要的内存不够。</li><li>当发现内存不够就会调用一次GC进行垃圾回收。</li></ul><h3 id="三-内存抖动"><a href="#三-内存抖动" class="headerlink" title="三. 内存抖动"></a>三. 内存抖动</h3><p>原因：内存抖动是因为应用程序在短时间内创建大量的对象，又被马上释放。</p><ul><li>瞬间产生大量的对象会严重占用Young Generation的内存区域。</li><li>当达到阈值，剩余空间不够，就会触发GC从而导致刚产生的对象又很快被回收。</li><li>即时每次分配的对象占用了很少的内存，频分GC叠加在一起会增加Heap的压力从而触发更多其他类型的GC。</li></ul><p>结果：这个操作有可能会影响到帧率，并使用户感知到性能问题。</p><h3 id="四-内存检测工具"><a href="#四-内存检测工具" class="headerlink" title="四. 内存检测工具"></a>四. 内存检测工具</h3><h4 id="1-Memeory-Profiler-内存监视器"><a href="#1-Memeory-Profiler-内存监视器" class="headerlink" title="1.Memeory Profiler 内存监视器"></a>1.Memeory Profiler 内存监视器</h4><p>Memeory Profiler是Android Profiler是Android Studio3.0用来替换之前Android Monitor(Allocation Tracker，Heap Viewer)的观察工具，主要用来观察内存，网络，cpu温度。</p><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/profiler_show.png" alt=""></p><p>Memoey Profiler的使用参考：<a href="https://developer.android.google.cn/studio/profile/memory-profiler.html">官方文档</a></p><h4 id="2-Leak-Canary"><a href="#2-Leak-Canary" class="headerlink" title="2. Leak Canary"></a>2. Leak Canary</h4><p><a href="https://github.com/square/leakcanary">官方地址</a>，Leak Canary是Square公司基于MAT开源的一个工具，用来检测Android App中的内存泄露问题。</p><p>使用参考文档：<a href="https://www.jianshu.com/p/b83ddffcb3b5">LeakCanary</a></p><h3 id="五-常见的内存泄漏问题"><a href="#五-常见的内存泄漏问题" class="headerlink" title="五.常见的内存泄漏问题"></a>五.常见的内存泄漏问题</h3><h4 id="1-单例造成的泄漏"><a href="#1-单例造成的泄漏" class="headerlink" title="1. 单例造成的泄漏"></a>1. 单例造成的泄漏</h4><p>将Context对象保存在单例模式中，instance对象本身持有一个Context对象的引用，活动即时被销毁也不能被回收，因为静态变量一直持有它的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    使用Application的Context（也可以用自定义的Application）</span></span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-非静态内部类的静态实例造成的泄漏"><a href="#2-非静态内部类的静态实例造成的泄漏" class="headerlink" title="2. 非静态内部类的静态实例造成的泄漏"></a>2. 非静态内部类的静态实例造成的泄漏</h4><p>静态的sResource在创建时会间接持有一个MainActivity实例的引用，导致MainActivity无法被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestResource sResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> （sResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sResource = <span class="keyword">new</span> TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例</span><br><span class="line"></span><br><span class="line">如果用到Context就使用Application的Context</span><br><span class="line"></span><br><span class="line">但是Dialog不能使用Application和Service的Context</span><br></pre></td></tr></table></figure><h4 id="3-Handler-造成的内存泄漏问题"><a href="#3-Handler-造成的内存泄漏问题" class="headerlink" title="3. Handler 造成的内存泄漏问题"></a>3. Handler 造成的内存泄漏问题</h4><p>当创建匿名对象时，该对象会间接持有外部类实例的一个引用，mHandler对象本身会持有MainActivity的引用，导致MainActivity销毁后无法即时被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Activity中避免使用非静态内部类，比如将Handler声明为静态的，这样Handler的存活时间就与Activity无关了</p><p>同时引入弱引用的方式引入Activity，避免将Activity作为Context传入</p><p>使用前判空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference mActivity;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span></span>&#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> WeakReference(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-集合类泄漏"><a href="#4-集合类泄漏" class="headerlink" title="4. 集合类泄漏"></a>4. 集合类泄漏</h4><ul><li>如果集合类是全局的变量（类中的静态属性，全局性的map等既有静态引用或final一直指向它）</li><li>没有相应的删除机制</li><li>很可能导致集合所占用的内存只增不减</li></ul><h3 id="六-避免内存泄漏的方法"><a href="#六-避免内存泄漏的方法" class="headerlink" title="六. 避免内存泄漏的方法"></a>六. 避免内存泄漏的方法</h3><ol><li>尽量不要让静态变量引用Activity</li><li>使用WeakReference弱引用，会保证GC时会被回收</li><li>使用静态内部类来代替内部类，静态内部类不持有外部类的引用</li><li>静态内部类使用弱引用来引用外部类</li><li>在声明周期结束的时候释放资源</li></ol><h3 id="七-减少内存使用"><a href="#七-减少内存使用" class="headerlink" title="七. 减少内存使用"></a>七. 减少内存使用</h3><ol><li>使用更轻量的数据结构（SpareArray代替HashMap）</li><li>避免在onDraw方法中创建对象<ul><li>onDraw()方法被频繁调用，在其中创建对象会导致临时对象过多，发生内存抖动</li></ul></li><li>对象池（Message.obtain()）<ul><li>当一定要在onDraw中创建对象，推荐使用对象池</li><li>相当于对象缓冲，在创建时查找是否已经存在对象，没有在创建</li></ul></li><li>LRUCache</li><li>Bitmap内存复用，压缩（inSampleSize,inBitmap）</li><li>StringBuilder</li></ol><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://juejin.im/entry/581b30caa0bb9f00589a3623">Android 内存管理</a></p><hr><p>暂停跟新一段时间，找到工作后后续内容：</p><p>Android性能优化-布局优化</p><p>Android性能优化-电量优化</p><p>Android性能优化-网络优化</p><p>Android性能优化-Bitmap优化</p><p>Android性能优化-其他优化</p><p>设计模式：</p><p><a href="https://www.jianshu.com/p/1dc997737dd3">Android的设计模式-享元模式</a></p><p><a href="https://www.jianshu.com/p/ff909f9d925f">Android的设计模式-命令模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android性能优化" scheme="http://182.254.228.71/categories/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android项目：驾考宝典</title>
    <link href="http://182.254.228.71/Android%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%A9%BE%E8%80%83%E5%AE%9D%E5%85%B8/"/>
    <id>http://182.254.228.71/Android%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%A9%BE%E8%80%83%E5%AE%9D%E5%85%B8/</id>
    <published>2020-06-20T16:02:23.000Z</published>
    <updated>2020-06-20T16:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="一-运行效果以及源码"><a href="#一-运行效果以及源码" class="headerlink" title="一. 运行效果以及源码"></a>一. 运行效果以及源码</h3><h4 id="1-gif图效果"><a href="#1-gif图效果" class="headerlink" title="1.gif图效果"></a>1.gif图效果</h4><p><img src="https://hexo-photo-1300729795.cos.ap-nanjing.myqcloud.com/hexo-article/Android%E9%A1%B9%E7%9B%AE%EF%BC%9A%E9%A9%BE%E8%80%83%E5%AE%9D%E5%85%B8/DriveQuestion.gif" alt=""></p><h4 id="2-源码地址"><a href="#2-源码地址" class="headerlink" title="2.源码地址"></a>2.源码地址</h4><p><a href="https://github.com/xiaoshitounen/DriveQuestion">DriveQuestion</a></p><h3 id="二-主要的思路"><a href="#二-主要的思路" class="headerlink" title="二.主要的思路"></a>二.主要的思路</h3><p>使用OKHttp+Gson将服务器端的数据显示到ViewPager上。</p><p>数据来自：<a href="https://www.avatardata.cn/Docs/Api/1ccd64af-d0d9-4ddd-8bac-660344cf2f21">阿凡达数据-驾照题库</a></p><h3 id="三-使用到的技术点"><a href="#三-使用到的技术点" class="headerlink" title="三.使用到的技术点"></a>三.使用到的技术点</h3><p><a href="/Android控件-ViewPager/">Android控件-ViewPager/</a></p><p><a href="/Android网络-OkHttp基本使用/">Android网络-OkHttp基本使用</a></p><p><a href="/Android网络-解析Json数据/">Android网络-解析Json数据</a></p><h3 id="四-对应论文"><a href="#四-对应论文" class="headerlink" title="四. 对应论文"></a>四. 对应论文</h3><p>链接:<a href="https://pan.baidu.com/s/1MmuDzC0K1B5Ph4HQc4kcWQ">https://pan.baidu.com/s/1MmuDzC0K1B5Ph4HQc4kcWQ</a>  密码:t5id</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Android项目" scheme="http://182.254.228.71/categories/Android%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android" scheme="http://182.254.228.71/tags/Android/"/>
    
  </entry>
  
</feed>
