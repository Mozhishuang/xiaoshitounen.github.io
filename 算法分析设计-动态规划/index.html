<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="https://xl-head-portrait-1300729795.cos.ap-chengdu.myqcloud.com/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="https://xl-head-portrait-1300729795.cos.ap-chengdu.myqcloud.com/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="算法,"><link rel="alternate" href="/atom.xml" title="小石头's Blog" type="application/atom+xml"><meta name="description" content="一. 动态规划（Dynamic programm）1. 什么是动态规划？动态规划，英文是Dynamic Programming，简称DP，擅长解决“多阶段决策问题”，利用各个阶段阶段的递推关系，逐个确定每个阶段的最优决策，并最终得到原问题的最优决策。 2. 动态规划的适用条件 一个问题的求解可以拆分为若干个阶段的子问题。 问题的最优解依赖于子问题的最优解。 一个问题的求解过程中，其子问题可能会重复"><meta property="og:type" content="article"><meta property="og:title" content="算法分析设计-动态规划"><meta property="og:url" content="http://fanandjiu.com/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html"><meta property="og:site_name" content="小石头&#39;s Blog"><meta property="og:description" content="一. 动态规划（Dynamic programm）1. 什么是动态规划？动态规划，英文是Dynamic Programming，简称DP，擅长解决“多阶段决策问题”，利用各个阶段阶段的递推关系，逐个确定每个阶段的最优决策，并最终得到原问题的最优决策。 2. 动态规划的适用条件 一个问题的求解可以拆分为若干个阶段的子问题。 问题的最优解依赖于子问题的最优解。 一个问题的求解过程中，其子问题可能会重复"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/LCS_table.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/short_path.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/materix.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/beibao_proplem.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/beibao.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/MinTriagulation.png"><meta property="og:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/OptimalBinarySearch.png"><meta property="article:published_time" content="2020-04-14T13:12:15.000Z"><meta property="article:modified_time" content="2020-06-22T09:55:58.277Z"><meta property="article:author" content="小石头"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/LCS_table.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:0,b2t:!0,scrollpercent:!0,onmobile:!0},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://fanandjiu.com/算法分析设计-动态规划/"><title>算法分析设计-动态规划 | 小石头's Blog</title><meta name="generator" content="Hexo 4.2.1"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">小石头's Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">成功来源于每一次的坚持</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://fanandjiu.com/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="小石头"><meta itemprop="description" content=""><meta itemprop="image" content="https://xl-head-portrait-1300729795.cos.ap-chengdu.myqcloud.com/acatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="小石头's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">算法分析设计-动态规划</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T21:12:15+08:00">2020-04-14</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">算法分析设计</span></a></span></span> <span class="post-comments-count"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span><a href="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="commentCount"></span></a></span> <span id="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="leancloud_visitors" data-flag-title="算法分析设计-动态规划"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">热度&#58;</span><span class="leancloud-visitors-count"></span> <span>℃</span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">5.8k 字</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">28 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h3 id="一-动态规划（Dynamic-programm）"><a href="#一-动态规划（Dynamic-programm）" class="headerlink" title="一. 动态规划（Dynamic programm）"></a>一. 动态规划（Dynamic programm）</h3><h4 id="1-什么是动态规划？"><a href="#1-什么是动态规划？" class="headerlink" title="1. 什么是动态规划？"></a>1. 什么是动态规划？</h4><p>动态规划，英文是Dynamic Programming，简称DP，擅长解决“多阶段决策问题”，利用各个阶段阶段的递推关系，逐个确定每个阶段的最优决策，并最终得到原问题的最优决策。</p><h4 id="2-动态规划的适用条件"><a href="#2-动态规划的适用条件" class="headerlink" title="2. 动态规划的适用条件"></a>2. 动态规划的适用条件</h4><ul><li><strong>一个问题的求解可以拆分为若干个<code>阶段</code>的子问题。</strong></li><li><strong>问题的最优解<code>依赖</code>于子问题的最优解。</strong></li><li><strong>一个问题的求解过程中，其子问题可能会<code>重复</code>出现。</strong>（如斐波那锲数列子问题重复太多，导致时间复杂度高，所以动态规划需要规避重复）</li></ul><h3 id="二-跳跃游戏"><a href="#二-跳跃游戏" class="headerlink" title="二. 跳跃游戏"></a>二. 跳跃游戏</h3><h4 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p>给定一个非负整数数组，你最初位于数组的第一一个位<br>置。数组中的每个元素代表你在该位置可以跳跃的最<br>大长度。判断你是否能够到达最后一个位置。</p><p>数组1： 2 3 1 1 4</p><p>数组2：3 2 1 0 4</p><h4 id="2-暴力求解（Brute-）"><a href="#2-暴力求解（Brute-）" class="headerlink" title="2. 暴力求解（Brute ）"></a>2. 暴力求解（Brute ）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力求解法</span></span><br><span class="line"><span class="comment">//思路：遍历每一个位置，找到该位置可以跳的所有位置，打上标记</span></span><br><span class="line"><span class="comment">//缺点：有的位置可能多次被打上标记，浪费时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJumpByBruteForce</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//记录每一个位置是否可以跳</span></span><br><span class="line">    <span class="keyword">boolean</span>[] reachable = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    <span class="comment">//第一个位置默认是可以跳的</span></span><br><span class="line">    reachable[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举每一个位置，给每个位置可以跳到的位置打上标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//判断当前位置是否可以到达</span></span><br><span class="line">        <span class="keyword">if</span> (reachable[i])&#123;</span><br><span class="line">            <span class="comment">//找到当前位置可以跳的所有位置（不能越界），打上标记</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums[i] &amp;&amp; i+j &lt; nums.length; j++) &#123;</span><br><span class="line">                reachable[i+j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reachable[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度最坏情况下：</p><p>每一个位置跳的长度都是从当前位置当最后的位置：(n-2)+(n-3)+…+1 =&gt; O(n<sup>2</sup>)</p><h4 id="3-动态规划（Dynamic-programming）"><a href="#3-动态规划（Dynamic-programming）" class="headerlink" title="3. 动态规划（Dynamic programming）"></a>3. 动态规划（Dynamic programming）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="comment">//思路：主要解决了暴力求解可能多次打上标记的问题</span></span><br><span class="line"><span class="comment">//倒着跳，从倒数第二个位置开始跳看是否能跳到第一个（子问题：第二个能否跳到第一个也倒着跳）</span></span><br><span class="line"><span class="comment">//不能的话从倒数第三个位置开始跳看是否能跳到第一个</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//这样就避免了重复打标记的问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJumpByDp</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJump(nums,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//能否从第tail+1个位置跳到第一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束的条件</span></span><br><span class="line">    <span class="comment">//判断是否跳到了第一个</span></span><br><span class="line">    <span class="keyword">if</span> (tail == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依次倒着跳，找到结果就跳出来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tail-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//判断当前位置是否可以跳到上一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= tail) &#123;</span><br><span class="line">            <span class="comment">//慢慢跳</span></span><br><span class="line">            <span class="keyword">return</span> canJump(nums,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码进入到这里肯定没成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：θ(n)</p><p>倒着跳，平均每个位置经过依次。</p><h4 id="4-巧妙解法"><a href="#4-巧妙解法" class="headerlink" title="4. 巧妙解法"></a>4. 巧妙解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巧妙解法：不能出现 "0" 点</span></span><br><span class="line"><span class="comment">//两个选择：1.不能出现0点</span></span><br><span class="line"><span class="comment">//        2.该0点可以被跳掉</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canJumpByZeroPoint</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  <span class="comment">//数组长度</span></span><br><span class="line">  <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否有0点,默认状态-1,没有0点</span></span><br><span class="line">  <span class="keyword">int</span> zeroPoint = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从倒数第二个位置开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">//判断当前位置是不是0点</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//存在0点</span></span><br><span class="line">      <span class="comment">//首先记录第一个0点</span></span><br><span class="line">      <span class="comment">//如果之后出现了可以跳过的点</span></span><br><span class="line">      <span class="comment">//那么就算之间出现的新的0点</span></span><br><span class="line">      <span class="comment">//也会被跳过去，无需考虑</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//如果跳不过去，白搭</span></span><br><span class="line">      <span class="keyword">if</span> (zeroPoint == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//设置0点的位置</span></span><br><span class="line">        zeroPoint = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (zeroPoint != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//当前位置不是0点，且之前有0点，检查是否能跳过</span></span><br><span class="line">      <span class="keyword">if</span> (i + nums[i] &gt; zeroPoint) &#123;</span><br><span class="line">        zeroPoint = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> zeroPoint == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-最大子串和问题"><a href="#三-最大子串和问题" class="headerlink" title="三. 最大子串和问题"></a>三. 最大子串和问题</h3><p>例:最佳投资时机<br>假设你已经预测到未来几期的股票市场价格，在这期间<br>你只能买卖一次，请问你该在何时买何时卖?</p><p>Day 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16<br>Price 100 113 110 85 105 102 86 63 81 101 94 106 101 79 94 90 97</p><h4 id="1-暴力求解（Brute-force）"><a href="#1-暴力求解（Brute-force）" class="headerlink" title="1.暴力求解（Brute force）"></a>1.暴力求解（Brute force）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力求解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getByBruteForce(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="comment">//存储 最大收益 购买时间 卖出时间的变量</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>,startIndex = <span class="number">0</span>,endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一种情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="comment">//如果收益超过了当前的最大值 更换最大值</span></span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; maxSum)&#123;</span><br><span class="line">                maxSum = prices[j] - prices[i];</span><br><span class="line">                startIndex = i;</span><br><span class="line">                endIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：θ(n<sup>2</sup>)</p><h4 id="2-分治法（Divide-and-conquer）"><a href="#2-分治法（Divide-and-conquer）" class="headerlink" title="2. 分治法（Divide and conquer）"></a>2. 分治法（Divide and conquer）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治求解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] getByDivideConquer(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="comment">//将每天的资金数据转化为当天和前一天的数据差-&gt;最大子串和问题</span></span><br><span class="line">    <span class="keyword">int</span>[] changes = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; changes.length; i++) &#123;</span><br><span class="line">        changes[i] = prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSubArray(changes,<span class="number">0</span>,changes.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解最大子数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> changes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tail</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxSubArray(<span class="keyword">int</span>[] changes, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)&#123;</span><br><span class="line">    <span class="comment">//存储 最大收益 购买时间 卖出时间的变量</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>,startIndex = <span class="number">0</span>,endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)&#123;</span><br><span class="line">        maxSum = changes[head];</span><br><span class="line">        startIndex = head;</span><br><span class="line">        endIndex = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分治处理</span></span><br><span class="line">    <span class="keyword">int</span> middle = (head+tail) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右数组的最大值</span></span><br><span class="line">    <span class="keyword">int</span>[] maxLeft = maxSubArray(changes,head,middle);</span><br><span class="line">    <span class="keyword">int</span>[] maxRight = maxSubArray(changes,middle+<span class="number">1</span>,tail);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找出最大值</span></span><br><span class="line">    <span class="keyword">if</span> (maxLeft[<span class="number">0</span>] &gt; maxRight[<span class="number">0</span>])&#123;</span><br><span class="line">        maxSum = maxLeft[<span class="number">0</span>];</span><br><span class="line">        startIndex = maxLeft[<span class="number">1</span>];</span><br><span class="line">        endIndex = maxLeft[<span class="number">2</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        maxSum = maxRight[<span class="number">0</span>];</span><br><span class="line">        startIndex = maxRight[<span class="number">1</span>];</span><br><span class="line">        endIndex = maxRight[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含左右子数组的最大值</span></span><br><span class="line">    <span class="keyword">int</span>[] maxTwoSide = maxTwoSide(changes,head,tail,middle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续找</span></span><br><span class="line">    <span class="keyword">if</span> (maxTwoSide[<span class="number">0</span>] &gt; maxSum)&#123;</span><br><span class="line">        maxSum = maxTwoSide[<span class="number">0</span>];</span><br><span class="line">        startIndex = maxTwoSide[<span class="number">1</span>];</span><br><span class="line">        endIndex = maxTwoSide[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求解包含左右子数组的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> changes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tail</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> middle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] maxTwoSide(<span class="keyword">int</span>[] changes, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> middle) &#123;</span><br><span class="line">    <span class="comment">//存储 最大收益 购买时间 卖出时间的变量</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = <span class="number">0</span>,startIndex = <span class="number">0</span>,endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)&#123;</span><br><span class="line">        maxSum = changes[head];</span><br><span class="line">        startIndex = head;</span><br><span class="line">        endIndex = tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前的和</span></span><br><span class="line">    <span class="keyword">int</span> currentSum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从索引处向左扩展</span></span><br><span class="line">    <span class="keyword">int</span> leftSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = middle; i &gt;= head; i--) &#123;</span><br><span class="line">        currentSum += changes[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftSum &lt; currentSum)&#123;</span><br><span class="line">            leftSum = currentSum;</span><br><span class="line"></span><br><span class="line">            startIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从索引处向右扩展</span></span><br><span class="line">    currentSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = middle+<span class="number">1</span>; i &lt;= tail; i++) &#123;</span><br><span class="line">        currentSum += changes[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rightSum &lt; currentSum)&#123;</span><br><span class="line">            rightSum = currentSum;</span><br><span class="line"></span><br><span class="line">            endIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大收益</span></span><br><span class="line">    maxSum = leftSum + rightSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于平面内最近点对的思想，但是更简单一点。</p><h4 id="3-动态规划（Dynamic-programming）-1"><a href="#3-动态规划（Dynamic-programming）-1" class="headerlink" title="3. 动态规划（Dynamic programming）"></a>3. 动态规划（Dynamic programming）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划求解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getByDynamicProgramming(<span class="keyword">int</span>[] prices) &#123;</span><br><span class="line">    <span class="comment">//将每天的资金数据转化为当天和前一天的数据差-&gt;最大子串和问题</span></span><br><span class="line">    <span class="keyword">int</span>[] changes = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; changes.length; i++) &#123;</span><br><span class="line">        changes[i] = prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储 最大收益 购买时间 卖出时间的变量</span></span><br><span class="line">    <span class="keyword">int</span> maxSum = changes[<span class="number">0</span>],startIndex = <span class="number">0</span>,endIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//累计收益</span></span><br><span class="line">    <span class="keyword">int</span> currentMaxSum = changes[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> currentIndex = <span class="number">1</span>; currentIndex &lt; changes.length; currentIndex++)&#123;</span><br><span class="line">        <span class="comment">//如果累计收益不是正的</span></span><br><span class="line">        <span class="keyword">if</span> (currentMaxSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//重新计算收益</span></span><br><span class="line">            currentMaxSum = changes[currentIndex];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更改起始位置</span></span><br><span class="line">            startIndex = currentIndex;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//收益累加</span></span><br><span class="line">            currentMaxSum += changes[currentIndex];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果累计收益大于最大收益</span></span><br><span class="line">        <span class="keyword">if</span> (currentMaxSum &gt; maxSum)&#123;</span><br><span class="line">            <span class="comment">//重新计算最大收益</span></span><br><span class="line">            maxSum = currentMaxSum;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更改结束位置</span></span><br><span class="line">            endIndex = currentIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;maxSum,startIndex,endIndex&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设只有前两天有买卖机会，最多赚多少钱?</p><p>假设只有前三天有买卖机会，最多赚多少钱?</p><p>假设只有前四天有买卖机会，最多赚多少钱?</p><p>。。。。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp; 1&emsp;&nbsp;2&emsp;&nbsp;&nbsp;&nbsp;3&emsp;&nbsp;&nbsp;&nbsp;4&emsp;&nbsp;&nbsp;5&emsp;&nbsp;6&emsp;&nbsp;&nbsp;&nbsp;7&emsp;&nbsp;&nbsp;8&emsp;&nbsp;&nbsp;9&emsp;&nbsp;&nbsp;10&emsp;11&emsp;&nbsp;12&emsp;&nbsp;13&emsp;&nbsp;14&emsp;15&emsp;16<br>价格变化&emsp;13&emsp;-3&emsp;-25&emsp;20&emsp;-3&emsp;16&emsp;-23&emsp;18&emsp;20&emsp;-7&emsp;12&emsp;-5&emsp;-22&emsp;15&emsp;-4&emsp;7<br>当前累积&emsp;13&emsp;10&emsp;&nbsp;&nbsp;0&emsp;&nbsp;&nbsp;20&emsp;&nbsp;17&emsp;&nbsp;1&emsp; &nbsp;&nbsp;0&emsp;&nbsp;18&emsp;38&emsp;&nbsp;31&emsp;43&emsp;38&emsp;&nbsp;16&emsp;&nbsp;31&emsp;27&emsp;34<br>最大收益&emsp;13&emsp;13&emsp;&nbsp;13&emsp;&nbsp;&nbsp;20&emsp;20&emsp;20&emsp;20&emsp;&nbsp;20&emsp;38&emsp;38&emsp;43&emsp;43&emsp;43&emsp;43&emsp;43&emsp;43</p><p>这样就将大问题化解为分阶段的小问题，使用动态规划。</p><p>时间复杂度：θ(n)（每个位置都经过一次）</p><h3 id="四-切木材问题"><a href="#四-切木材问题" class="headerlink" title="四. 切木材问题"></a>四. 切木材问题</h3><h4 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p>给一个长度为17的木材，可以切成小段卖出去，价<br>格根据小段的长度不同而不同。</p><p>Length i 1 2 3 4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;10<br>Price p<sub>i</sub> &nbsp;1 4 5 7 10 17 17 20 24 30</p><p>如何通过切成小段卖出尽可能高的总价钱?</p><h4 id="2-动态规划（Dynamic-programming）"><a href="#2-动态规划（Dynamic-programming）" class="headerlink" title="2.动态规划（Dynamic programming）"></a>2.动态规划（Dynamic programming）</h4><p>Length i 1 2 3 4 &nbsp;5 &nbsp;6 &nbsp;7 &nbsp;8 &nbsp;9 &nbsp;10<br>Price p<sub>i</sub> &nbsp;1 4 5 7 10 17 17 20 24 30<br>Value v<sub>i</sub> &nbsp;1 4 5 8 10 17 18 21 24 30</p><p>Length i 11 &nbsp;12 &nbsp;13 14 &nbsp;15 16 &nbsp;17<br>Value v<sub>i</sub> &nbsp;31 34 35 38 41 47 48</p><p>① 表格法：自下而上</p><p>时间复杂度：θ(n<sup>2</sup>)</p><p>for (int i = 1; i &lt; rod_length; i++) {<br> for (int j = 0; j &lt; i / 2; j++) { }<br>}</p><p>1/2 * 1 + 1/2 * 2 + 1/2 * 3 + … + 1/2 * n = 1/2 * 1/2 * n(1+n) = 1/4 * (n<sup>2</sup> + n) = θ(n<sup>2</sup>)</p><p>② 备忘录法：自上而下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切木头问题 动态规划</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCut</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表格法：自下而上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cut_value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rod_length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValueByTabulation</span><span class="params">(<span class="keyword">int</span>[] cut_value, <span class="keyword">int</span> rod_length)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存储每一个子阶段的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[] rod_value = <span class="keyword">new</span> <span class="keyword">int</span>[rod_length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度为1的木头价值就是其本身</span></span><br><span class="line">        rod_value[<span class="number">0</span>] = cut_value[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次求解之后每个子阶段的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rod_length; i++) &#123;</span><br><span class="line">            <span class="comment">//因为有可能最大的cut_value &lt; rod_length</span></span><br><span class="line">            <span class="comment">//所以需要判断能不能不切直接卖</span></span><br><span class="line">            rod_value[i] = cut_value[Math.min(i,cut_value.length-<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i-j-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                rod_value[i] = Math.max(</span><br><span class="line">                        rod_value[i],</span><br><span class="line">                        rod_value[j] + rod_value[i-j-<span class="number">1</span>]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rod_value[rod_length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录法：自上而下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cut_value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rod_length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValueByMemoization</span><span class="params">(<span class="keyword">int</span>[] cut_value, <span class="keyword">int</span> rod_length)</span></span>&#123;</span><br><span class="line">        <span class="comment">//存储每一个子阶段的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[] rod_value = <span class="keyword">new</span> <span class="keyword">int</span>[rod_length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度为1的木头价值就是其本身</span></span><br><span class="line">        rod_value[<span class="number">0</span>] = cut_value[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getValueByMemoization(cut_value, rod_length, rod_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValueByMemoization</span><span class="params">(<span class="keyword">int</span>[] cut_value, <span class="keyword">int</span> rod_length, <span class="keyword">int</span>[] rod_value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (rod_value[rod_length-<span class="number">1</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> rod_value[rod_length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为有可能最大的cut_value &lt; rod_length</span></span><br><span class="line">        <span class="comment">//所以需要判断能不能不切直接卖</span></span><br><span class="line">        rod_value[rod_length-<span class="number">1</span>] = cut_value[Math.min(rod_length-<span class="number">1</span>,cut_value.length-<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (rod_length-<span class="number">1</span>) - j -<span class="number">1</span>; j++) &#123;</span><br><span class="line">            rod_value[rod_length-<span class="number">1</span>] = Math.max(</span><br><span class="line">                    rod_value[rod_length-<span class="number">1</span>],</span><br><span class="line">                    getValueByMemoization(cut_value,j+<span class="number">1</span>,rod_value) +</span><br><span class="line">                    getValueByMemoization(cut_value,rod_length-j-<span class="number">1</span>,rod_value)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rod_value[rod_length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> swu.xl.algorithm.code_04_21.experiment_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RodCutTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">int</span>[] cut_value = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">30</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> rod_length = <span class="number">17</span>;</span><br><span class="line">		System.out.println(RodCut.getValueByTabulation(cut_value,rod_length));</span><br><span class="line">		System.out.println(RodCut.getValueByMemoization(cut_value,rod_length));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><h3 id="五-最长公共子序列"><a href="#五-最长公共子序列" class="headerlink" title="五.最长公共子序列"></a>五.最长公共子序列</h3><h4 id="1-题目描述-2"><a href="#1-题目描述-2" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p>求解 X (A,B,C,B,D,A,B) Y (B,D,C,A,B,A) 的最长公共子序列</p><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/LCS_table.png" alt=""></p><h4 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h4><p>① 表格法：自下而上</p><p>时间复杂度：θ(n<sup>2</sup>)</p><p>求出一个表格的所有位置 m*n</p><p>② 备忘录法：自上而下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swu.xl.algorithm.code_04_21.experiment_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最长公共子序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCS</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表格法：自下向上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLCSByTabulation</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表格的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> row_num = str1.length();</span><br><span class="line">        <span class="keyword">int</span> col_num = str2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表格的数据结构</span></span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[row_num][col_num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表格的第一行，第一列元素</span></span><br><span class="line">        board[<span class="number">0</span>][<span class="number">0</span>] = (str1.charAt(<span class="number">0</span>) == str2.charAt(<span class="number">0</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一列元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row_num; i++) &#123;</span><br><span class="line">            board[i][<span class="number">0</span>] = (str1.charAt(i) == str2.charAt(<span class="number">0</span>) || board[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; col_num; i++) &#123;</span><br><span class="line">            board[i][<span class="number">0</span>] = (str1.charAt(<span class="number">0</span>) == str2.charAt(i) || board[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化表格其他位置的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row_num; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col_num; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j))&#123;</span><br><span class="line">                    board[i][j] = board[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    board[i][j] = Math.max(</span><br><span class="line">                            board[i-<span class="number">1</span>][j],</span><br><span class="line">                            board[i][j-<span class="number">1</span>]</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逆着找到一个最长字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟指针</span></span><br><span class="line">        <span class="keyword">int</span> i = row_num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = col_num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储找到的字符串</span></span><br><span class="line">        StringBuilder lcs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找</span></span><br><span class="line">        <span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == board[i-<span class="number">1</span>][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == board[i][j-<span class="number">1</span>])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                lcs.insert(<span class="number">0</span>, str1.charAt(i));</span><br><span class="line">                i--;j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lcs.insert(<span class="number">0</span>, str1.charAt(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lcs.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备忘录法：自上向下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getLCSByMemoization</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格的行数和列数</span></span><br><span class="line">        <span class="keyword">int</span> row_num = str1.length();</span><br><span class="line">        <span class="keyword">int</span> col_num = str2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表格的数据结构</span></span><br><span class="line">        <span class="keyword">int</span>[][] board = <span class="keyword">new</span> <span class="keyword">int</span>[row_num][col_num];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟指针</span></span><br><span class="line">        <span class="keyword">int</span> i = row_num - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = col_num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储找到的字符串</span></span><br><span class="line">        StringBuilder lcs= <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逆着找</span></span><br><span class="line">        <span class="keyword">while</span>(i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)&#123;</span><br><span class="line">            board[i][j] = getLCSByMemoization(board, str1, str2, i, j);</span><br><span class="line">            board[i-<span class="number">1</span>][j] = getLCSByMemoization(board, str1, str2, i-<span class="number">1</span>, j);</span><br><span class="line">            board[i][j-<span class="number">1</span>] = getLCSByMemoization(board, str1, str2, i, j-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == board[i-<span class="number">1</span>][j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == board[i][j-<span class="number">1</span>]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lcs.insert(<span class="number">0</span>, str1.charAt(i));</span><br><span class="line">                i--;j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lcs.insert(<span class="number">0</span>, str1.charAt(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lcs.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLCSByMemoization</span><span class="params">(<span class="keyword">int</span>[][] board, String str1, String str2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(board[m][n] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> board[m][n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str1.charAt(m) == str2.charAt(n))&#123;</span><br><span class="line">            board[m][n] = <span class="number">1</span> + getLCSByMemoization(board, str1,str2,m-<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(</span><br><span class="line">                    getLCSByMemoization(board, str1,str2,m-<span class="number">1</span>,n),</span><br><span class="line">                    getLCSByMemoization(board, str1,str2,m,n-<span class="number">1</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> board[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> swu.xl.algorithm.code_04_21.experiment_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LCSTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		String str1 = <span class="string">"ABCBDAB"</span>;</span><br><span class="line">		String str2 = <span class="string">"BDCABA"</span>;</span><br><span class="line">		System.out.println(LCS.getLCSByTabulation(str1,str2));</span><br><span class="line">		System.out.println(LCS.getLCSByMemoization(str1,str2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">BDAB</span><br><span class="line">BCBA</span><br></pre></td></tr></table></figure><p>表格法和备忘录法的区别</p><p>表格法：每个子问题都要求解一次，但不会重复求解子问题。自底向上。</p><p>备忘录法：只求解哪些确实需要解的子问题。自顶向下。</p><h3 id="六-最短路径问题"><a href="#六-最短路径问题" class="headerlink" title="六. 最短路径问题"></a>六. 最短路径问题</h3><h4 id="1-题目描述-3"><a href="#1-题目描述-3" class="headerlink" title="1.题目描述"></a>1.题目描述</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/short_path.png" alt=""></p><h4 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2. 代码"></a>2. 代码</h4><p>时间复杂度：θ(m<sup>2</sup>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPath</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最短路径问题（有向无环图）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> distances</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> origin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destination</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList&lt;String&gt; <span class="title">getByDP</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HashMap&lt;String, LinkedList&lt;String&gt;&gt; routes,</span></span></span><br><span class="line"><span class="function"><span class="params">            HashMap&lt;String, LinkedList&lt;Integer&gt;&gt; distances,</span></span></span><br><span class="line"><span class="function"><span class="params">            String origin, String destination)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储到达某一个点的最短距离的上一个点的信息</span></span><br><span class="line">        HashMap&lt;String, String&gt; shortest_routes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//存储到达某一个点的最短距离</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; shortest_distances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入起点边信息 起点不需要存储点信息</span></span><br><span class="line">        shortest_distances.put(origin,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//加入第一个点</span></span><br><span class="line">        q.add(<span class="string">"A"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有的点的最短路径求完</span></span><br><span class="line">        <span class="keyword">while</span> (q.peek() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//取出队列首元素</span></span><br><span class="line">            String node = q.remove();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//求解出当前点可以到达点的距离信息</span></span><br><span class="line">            <span class="keyword">if</span> (routes.get(node) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将当前点可以到达的所有下一个点放到队列中</span></span><br><span class="line">                q.addAll(routes.get(node));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//依次求解当前点到它可以到达的所有点的距离</span></span><br><span class="line">                <span class="comment">//可能1：这个点没有到达过，直接填入求解的值</span></span><br><span class="line">                <span class="comment">//可能2：这个点到达过，需要判断能否更短</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routes.get(node).size(); i++) &#123;</span><br><span class="line">                    <span class="comment">//取得当前点要到达的点</span></span><br><span class="line">                    String toNode = routes.get(node).get(i);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//取出距离</span></span><br><span class="line">                    <span class="keyword">int</span> dist = distances.get(node).get(i);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//可能1 还没有到达 直接加入</span></span><br><span class="line">                    <span class="keyword">if</span> (!shortest_distances.containsKey(toNode))&#123;</span><br><span class="line">                        shortest_routes.put(toNode,node);</span><br><span class="line">                        shortest_distances.put(toNode,shortest_distances.get(node) + dist);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//可能2 到达过 判断能否更短</span></span><br><span class="line">                        <span class="keyword">if</span> (shortest_distances.get(toNode) &gt; shortest_distances.get(node) + dist)&#123;</span><br><span class="line">                            shortest_routes.put(toNode,node);</span><br><span class="line">                            shortest_distances.put(toNode,shortest_distances.get(node) + dist);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回路径</span></span><br><span class="line">        LinkedList&lt;String&gt; route = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        route.add(destination);</span><br><span class="line">        <span class="keyword">while</span> (shortest_routes.get(route.get(<span class="number">0</span>)) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            route.add(<span class="number">0</span>,shortest_routes.get(route.get(<span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> route;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七-矩阵连乘问题"><a href="#七-矩阵连乘问题" class="headerlink" title="七. 矩阵连乘问题"></a>七. 矩阵连乘问题</h3><h4 id="1-题目描述-4"><a href="#1-题目描述-4" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p>口 A是一个5x3的矩阵<br>口 A2是-一个3x4的矩阵<br>口 A3是一个4x2的矩阵<br>口 A4是一个2x7的矩阵<br>口 A5是一个7x5的矩阵<br>口 求矩阵连乘 A = A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>的最优计算次序和所需的乘法次数?</p><h4 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2. 代码"></a>2. 代码</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/materix.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixChainMultiplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求解矩阵连续乘的问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dims</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinMultiplicationNum</span><span class="params">(<span class="keyword">int</span>[] dims)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表格的长度</span></span><br><span class="line">        <span class="keyword">int</span> n = dims.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录连乘结果最小值的表格</span></span><br><span class="line">        <span class="keyword">int</span>[][] tab_num = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录连乘结果最小值时，划分的界限的后一个位置</span></span><br><span class="line">        <span class="keyword">int</span>[][] tab_split = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解出表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="comment">//先确认num表的初值</span></span><br><span class="line">                tab_num[i][j] = tab_num[i][j-<span class="number">1</span>] + dims[i] * dims[j] * dims[j+<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//再确认split表的初值</span></span><br><span class="line">                tab_split[i][j] = j;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//从所有可能中找到最小的</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++)&#123;</span><br><span class="line">                    <span class="comment">//记录新的一种搭配的值</span></span><br><span class="line">                    <span class="comment">//前半段：tab_num[i][k-1]</span></span><br><span class="line">                    <span class="comment">//后半段：tab_num[k][j]</span></span><br><span class="line">                    <span class="keyword">int</span> temp = tab_num[i][k-<span class="number">1</span>] + tab_num[k][j] +  dims[i] * dims[k] * dims[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断是不是更优解</span></span><br><span class="line">                    <span class="keyword">if</span> (temp &lt; tab_num[i][j])&#123;</span><br><span class="line">                        tab_num[i][j] = temp;</span><br><span class="line">                        tab_split[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印两个表格的数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab_num.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tab_num[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                String str = String.format(<span class="string">"%-3s"</span>, tab_num[i][j]);</span><br><span class="line">                System.out.print(str+<span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab_split.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tab_split[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                String str = String.format(<span class="string">"%-3s"</span>, tab_split[i][j]);</span><br><span class="line">                System.out.print(str+<span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归求解结果</span></span><br><span class="line">        trackBack(tab_split,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tab_num[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归求解分割方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab_split</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackBack</span><span class="params">(<span class="keyword">int</span>[][] tab_split, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            System.out.print(<span class="string">"A"</span>+(head+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"("</span>);</span><br><span class="line">            trackBack(tab_split,head,tab_split[head][tail]-<span class="number">1</span>);</span><br><span class="line">            trackBack(tab_split,tab_split[head][tail],tail);</span><br><span class="line">            System.out.print(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八-背包问题"><a href="#八-背包问题" class="headerlink" title="八. 背包问题"></a>八. 背包问题</h3><h4 id="1-题目描述-5"><a href="#1-题目描述-5" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/beibao_proplem.png" alt=""></p><h4 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2. 代码"></a>2. 代码</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/beibao.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> swu.xl.algorithm.code_04_28.experiment_3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 01背包问题-表格法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> items</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedList&lt;Integer&gt; <span class="title">getByTabulation</span><span class="params">(<span class="keyword">int</span>[][] items, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物品的个数</span></span><br><span class="line">        <span class="comment">//item 是一个二维数组 第一个值是占据的空间 第二个值是其价值</span></span><br><span class="line">        <span class="keyword">int</span> n = items.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前多少件物品和剩余空间求解最大价值的表格</span></span><br><span class="line">        <span class="comment">//tab[前多少件物品][空间] = 最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] tab = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][capacity+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次填表</span></span><br><span class="line">        <span class="comment">//注意：这里的i和c都是序号不是索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= capacity; c++) &#123;</span><br><span class="line">                <span class="comment">//如果还可以装的下</span></span><br><span class="line">                <span class="keyword">if</span> (c - items[i-<span class="number">1</span>][<span class="number">0</span>] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//是否装入该物品</span></span><br><span class="line">                    tab[i][c] = Math.max(</span><br><span class="line">                            tab[i-<span class="number">1</span>][c],</span><br><span class="line">                            tab[i-<span class="number">1</span>][c-items[i-<span class="number">1</span>][<span class="number">0</span>]] + items[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">                    );</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[i][c] = tab[i-<span class="number">1</span>][c];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解出装入背包的是那几项</span></span><br><span class="line">        LinkedList&lt;Integer&gt; packedItems = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> c = capacity;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//说明装入该物品</span></span><br><span class="line">            <span class="keyword">if</span> (tab[i][c] != tab[i-<span class="number">1</span>][c])&#123;</span><br><span class="line">                packedItems.add(<span class="number">0</span>,i);</span><br><span class="line">                c = c - items[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> packedItems;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九-凸多边形最优三角剖分问题"><a href="#九-凸多边形最优三角剖分问题" class="headerlink" title="九. 凸多边形最优三角剖分问题"></a>九. 凸多边形最优三角剖分问题</h3><h4 id="1-题目描述-6"><a href="#1-题目描述-6" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/MinTriagulation.png" alt=""></p><h4 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2. 代码"></a>2. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> point1;</span><br><span class="line">    <span class="keyword">int</span> point2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> point1, <span class="keyword">int</span> point2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.point1 = point1;</span><br><span class="line">        <span class="keyword">this</span>.point2 = point2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Answer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> LinkedList&lt;Edge&gt; partition;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> minCost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Answer</span><span class="params">(LinkedList&lt;Edge&gt; partition, <span class="keyword">double</span> minCost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partition = partition;</span><br><span class="line">        <span class="keyword">this</span>.minCost = minCost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinTriagulation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算给定的三个点组成的三角形的边长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> points</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">(<span class="keyword">double</span>[][] points, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(Math.pow(points[i][<span class="number">0</span>]-points[k][<span class="number">0</span>],<span class="number">2</span>) + Math.pow(points[i][<span class="number">1</span>]-points[k][<span class="number">1</span>],<span class="number">2</span>)) +</span><br><span class="line">                Math.sqrt(Math.pow(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>],<span class="number">2</span>) + Math.pow(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>],<span class="number">2</span>)) +</span><br><span class="line">                 Math.sqrt(Math.pow(points[j][<span class="number">0</span>]-points[k][<span class="number">0</span>],<span class="number">2</span>) + Math.pow(points[j][<span class="number">1</span>]-points[k][<span class="number">1</span>],<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求解凸多边形最优三角剖分问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> points</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回剖分方案和最小剖分成本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Answer <span class="title">getPartition</span><span class="params">(<span class="keyword">double</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多边形点的个数 或者 边数</span></span><br><span class="line">        <span class="keyword">int</span> n = points.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表格法的剖分成本表</span></span><br><span class="line">        <span class="keyword">double</span>[][] tab_cost = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        <span class="comment">//表格法的剖分方案表</span></span><br><span class="line">        <span class="keyword">int</span>[][] tab_split = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="comment">//设置默认值</span></span><br><span class="line">                tab_cost[i][j] = Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//求解某一个位置的最佳值 可能有很多种方案</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j-<span class="number">1</span>; k++)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tab_cost[i][j] &gt; (cost(points,i,j,k) + tab_cost[i][k] + tab_cost[k][j]) || tab_cost[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                        tab_cost[i][j] = cost(points,i,j,k) + tab_cost[i][k] + tab_cost[k][j];</span><br><span class="line">                        tab_split[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求解剖分方案</span></span><br><span class="line">        LinkedList&lt;Edge&gt; partition = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        trackback(tab_split,partition,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Answer(partition,tab_cost[<span class="number">0</span>][n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求解剖分方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab_split</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackback</span><span class="params">(<span class="keyword">int</span>[][] tab_split, LinkedList&lt;Edge&gt; partition, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j-i &gt; <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j - tab_split[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                partition.add(<span class="keyword">new</span> Edge(i,tab_split[i][j]));</span><br><span class="line"></span><br><span class="line">                trackback(tab_split,partition,i,tab_split[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tab_split[i][j] - i == <span class="number">1</span>)&#123;</span><br><span class="line">                partition.add(<span class="keyword">new</span> Edge(tab_split[i][j],j));</span><br><span class="line"></span><br><span class="line">                trackback(tab_split,partition,tab_split[i][j],j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinTriagulationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[][] points = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">        Answer ans = MinTriagulation.getPartition(points);</span><br><span class="line">        <span class="keyword">for</span>(Edge e : ans.partition) &#123;</span><br><span class="line">            System.out.println(<span class="string">"point"</span> + e.point1 + <span class="string">" ---- point"</span> + e.point2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans.minCost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">point1 ---- point4</span><br><span class="line">point1 ---- point3</span><br><span class="line"><span class="number">15.30056307974577</span></span><br></pre></td></tr></table></figure><h3 id="十-最优二叉树搜索问题"><a href="#十-最优二叉树搜索问题" class="headerlink" title="十. 最优二叉树搜索问题"></a>十. 最优二叉树搜索问题</h3><h4 id="1-题目描述-7"><a href="#1-题目描述-7" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h4><p><img src="https://algorithm-1300729795.cos.ap-chengdu.myqcloud.com/dp/OptimalBinarySearch.png" alt=""></p><h4 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="2. 代码"></a>2. 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimalBinarySearchTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求解最优二叉搜索树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key_probability 数据概率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy_probability 间隙概率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回最小成本，并打印动态规划的分支矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getMinCost</span><span class="params">(<span class="keyword">double</span>[] key_probability, <span class="keyword">double</span>[] dummy_probability)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连续概率表</span></span><br><span class="line">        <span class="keyword">int</span> n = dummy_probability.length;</span><br><span class="line">        <span class="keyword">double</span>[][] tab_continue = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        initContinueTab(tab_continue,key_probability,dummy_probability);</span><br><span class="line">        <span class="comment">//for (int i = 0; i &lt; tab_continue.length; i++) &#123;</span></span><br><span class="line">            <span class="comment">//for (int j = 0; j &lt; tab_continue[0].length; j++) &#123;</span></span><br><span class="line">                <span class="comment">//System.out.print(tab_continue[i][j]+" ");</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">            <span class="comment">//System.out.println();</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索成本表</span></span><br><span class="line">        <span class="keyword">double</span>[][] tab_search = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        <span class="comment">//分叉结点表</span></span><br><span class="line">        <span class="keyword">int</span>[][] tab_node = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="comment">//填入数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tab_search[i][i] = dummy_probability[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=j-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                tab_search[i][j] = Double.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=j;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(tab_search[i][j]&gt;tab_search[k][j]+tab_search[i][k-<span class="number">1</span>]+tab_continue[i][j])&#123;</span><br><span class="line">                        tab_search[i][j]=tab_search[k][j]+tab_search[i][k-<span class="number">1</span>]+tab_continue[i][j];</span><br><span class="line">                        tab_node[i][j]=k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab_node.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tab_node[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                System.out.print(tab_node[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tab_search[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化连续概率表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab_continue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key_probability</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy_probability</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initContinueTab</span><span class="params">(<span class="keyword">double</span>[][] tab_continue, <span class="keyword">double</span>[] key_probability, <span class="keyword">double</span>[] dummy_probability)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输入对角线的值</span></span><br><span class="line">        <span class="keyword">int</span> n = dummy_probability.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            tab_continue[i][i] = dummy_probability[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次填入其他部分的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="comment">//System.out.println("i:"+i+" j:"+j);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> p = i; p &lt;= j; p++)&#123;</span><br><span class="line">                    tab_continue[i][j] += dummy_probability[p];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (p != i)&#123;</span><br><span class="line">                        tab_continue[i][j] += key_probability[p-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimalBinarySearchTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] key_probability = &#123;<span class="number">0.15</span>, <span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.2</span>&#125; ;</span><br><span class="line">        <span class="keyword">double</span>[] dummy_probability = &#123; <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.1</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> cost = OptimalBinarySearchTree.getMinCost(key_probability,dummy_probability);</span><br><span class="line">        System.out.println(cost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">2.7500000000000004</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>问题分阶段</strong></p><p><strong>阶段有依赖</strong></p><p><strong>依赖有重叠</strong></p></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>Donate comment here</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.jpg" alt="小石头 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.jpg" alt="小石头 支付宝"><p>支付宝</p></div></div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法分析设计-动态规划</a></p><p><span>文章作者:</span><a href="/" title="访问 小石头 的个人博客">小石头</a></p><p><span>发布时间:</span>2020年04月14日 - 21:12</p><p><span>最后更新:</span>2020年06月22日 - 17:55</p><p><span>原始链接:</span><a href="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="算法分析设计-动态规划">http://fanandjiu.com/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://fanandjiu.com/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div><div style="text-align:center;color:#ccc;font-size:14px"> -------------本文结束<i class="fa fa-paw"></i> 感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3-1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/" rel="next" title="算法题解-1143. 最长公共子序列"><i class="fa fa-chevron-left"></i> 算法题解-1143. 最长公共子序列</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3-B-%E8%AF%95%E9%A2%98B%EF%BC%9A%E8%A1%8C%E5%8A%A8-5/" rel="prev" title="算法题解-B. 试题B：行动 5'">算法题解-B. 试题B：行动 5'<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div id="sidebar-dimmer"></div><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://xl-head-portrait-1300729795.cos.ap-chengdu.myqcloud.com/acatar.jpg" alt="小石头"><p class="site-author-name" itemprop="name">小石头</p><p class="site-description motion-element" itemprop="description">Life = Coding</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">238</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">11</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">27</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xiaoshitounen" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://gitee.com/xuxiaoshi" target="_blank" title="Gitee"><i class="fa fa-fw fa-free-code-camp"></i> Gitee</a></span><span class="links-of-author-item"><a href="https://xiaoshitounen.coding.net/admin/overview" target="_blank" title="Coding"><i class="fa fa-fw fa-file-code-o"></i> Coding</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/031c0a19d4a2" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐</div> <a href="https://www.showdoc.cc/" title="在线Api文档" target="_blank">在线Api文档</a> <a href="https://www.showdoc.cc/" title="在线作图" target="_blank">在线作图</a> <a href="http://www.atool9.com/colorpicker.php" title="在线颜色选择" target="_blank">在线颜色选择</a> <a href="https://www.iconfont.cn/" title="阿里巴巴矢量图标" target="_blank">阿里巴巴矢量图标</a> <a href="https://www.aconvert.com/cn/" title="在线转换" target="_blank">在线转换</a> <a href="http://tool.chinaz.com/tools/diff" title="文本对比" target="_blank">文本对比</a> <a href="https://www.ubuuk.com/" title="设计" target="_blank">设计</a> <a href="https://www.photopea.com/" title="在线PhotoShop" target="_blank">在线PhotoShop</a> <a href="https://tool.oschina.net/codeformat/json" title="代码格式化" target="_blank">代码格式化</a> <a href="https://smallpdf.com/cn" title="PDF转换" target="_blank">PDF转换</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-动态规划（Dynamic-programm）"><span class="nav-text">一. 动态规划（Dynamic programm）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是动态规划？"><span class="nav-text">1. 什么是动态规划？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-动态规划的适用条件"><span class="nav-text">2. 动态规划的适用条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-跳跃游戏"><span class="nav-text">二. 跳跃游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-暴力求解（Brute-）"><span class="nav-text">2. 暴力求解（Brute ）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-动态规划（Dynamic-programming）"><span class="nav-text">3. 动态规划（Dynamic programming）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-巧妙解法"><span class="nav-text">4. 巧妙解法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-最大子串和问题"><span class="nav-text">三. 最大子串和问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-暴力求解（Brute-force）"><span class="nav-text">1.暴力求解（Brute force）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-分治法（Divide-and-conquer）"><span class="nav-text">2. 分治法（Divide and conquer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-动态规划（Dynamic-programming）-1"><span class="nav-text">3. 动态规划（Dynamic programming）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-切木材问题"><span class="nav-text">四. 切木材问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-1"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-动态规划（Dynamic-programming）"><span class="nav-text">2.动态规划（Dynamic programming）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-最长公共子序列"><span class="nav-text">五.最长公共子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-2"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六-最短路径问题"><span class="nav-text">六. 最短路径问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-3"><span class="nav-text">1.题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码-1"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七-矩阵连乘问题"><span class="nav-text">七. 矩阵连乘问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-4"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码-2"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八-背包问题"><span class="nav-text">八. 背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-5"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码-3"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九-凸多边形最优三角剖分问题"><span class="nav-text">九. 凸多边形最优三角剖分问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-6"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码-4"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十-最优二叉树搜索问题"><span class="nav-text">十. 最优二叉树搜索问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-题目描述-7"><span class="nav-text">1. 题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-代码-5"><span class="nav-text">2. 代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright"><i class="fa fa-user-md"></i> <span id="busuanzi_container_site_uv">本站访客数:<span id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-area-chart"></i></span> <span class="post-meta-item-text">本站总字数&#58;</span> <span title="本站总字数">274.8k</span></div><div class="powered-by">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">小石头</span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '8Wr6djHK9j3sWcrUa0SljIrP-gzGzoHsz',
        appKey: 'zI5eAMr7Rto1tGdUu1LRRbzY',
        placeholder: 'Just go go',
        avatar:'monsterid',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("8Wr6djHK9j3sWcrUa0SljIrP-gzGzoHsz","zI5eAMr7Rto1tGdUu1LRRbzY")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/javascript" src="/js/src/love.js"></script></body></html>